

1、非多线程实例

2、多线程的创建和启动


1）子线程的创建和启动过程（继承的方式）

1. 继承 Thread 类


2）子线程的创建和启动过程（继承的方式）

2. 实现 Runnable 接口


3、承方式和实现方式的联系与区别


【区别】


【实现方法的好处】


4、Thread类

1）构造方法


2）Thread 类的有关方法 (1)


5、线程的调度


6、线程的优先级


Thread 类的有关方法 (2)


# 1、非多线程实例

```javascript
package com.java1;

/*
    1、以下就是一个单线程的程序
        判断方法：
            每一个方法都必须由另一个方法调用之后才能运行，
            并不能独立的运行；

            例如：main方法调用method2方法，
            method2方法调用method1方法；

            所以这些程序是必须按照先后顺序执行的，由此可见是单线程的；
*/
public class TestMain {
    public static void main(String args[]){         //主线程
        method2("java1");
    }
    public static void method1(String str){
        System.out.println("method1.....");
        System.out.println(str);
    }
    public static void method2(String str){
        System.out.println("method2......");
        method1(str);
    }
}
```



---

# 2、多线程的创建和启动


 Java 语言的 JVM 允许程序运行多个线程，它通过
java.lang.Thread 类来实现。


 Thread 类的特性


-  每个线程都是通过某个特定 Thread 对象的 run()
方法来完成操作的，经常把 run() 方法的主体称
为 线程体


-  通过该 Thread 对象的 start() 方法来调用这个线程



## 1）子线程的创建和启动过程（继承的方式）

### 1. 继承 Thread 类


- 1) 定义子类继承 Thread 类。


- 2) 子类中重写 Thread 类中的 run 方法。


- 3) 创建 Thread 子类对象，即创建了线程对象。


- 4) 调用线程对象 start 方法：启动线程，调用 run 方法。

```javascript
package com.exer;

class SubThread1 extends Thread{		//子线程
    public void run(){
        for(int i=0;i<=100;i++){
         if(i%2==0){
             System.out.println(Thread.currentThread().getName()+":"+i);
         }
        }
    }
}

class SubThread2 extends Thread{     	//子线程
    public void run(){
        for(int i=0;i<=100;i++){
            if(i%2!=0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}

public class TesThread {				//主线程
    public static void main(String args[]){
        SubThread1 st1=new SubThread1();
        SubThread2 st2=new SubThread2();
        st1.start();	//启动子线程
        st2.start();	//启动子线程
    }
}
```



## 2）子线程的创建和启动过程（继承的方式）

### 2. 实现 Runnable 接口


- 1 ）定义子类，实现 Runnable 接口。


- 2 ）子类中重写 Runnable 接口中的 run 方法。


- 3 ）通过 Thread 类含参构造器创建线程对象。


- 4 ）将 Runnable 接口的子类对象作为实际参数传递给
Thread 类的构造方法中。


- 5 ）调用 Thread 类的 start 方法：开启线程，调用
Runnable 子类接口的 run 方法。

```javascript
package com.exer;

/*
 *通过实现的方式
 */
class PrintNum1 implements Runnable{
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            if(i%2==0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}
public class TestThred1 {
      public static void main(String args[]){
            PrintNum1 p=new PrintNum1();
            Thread t1=new Thread(p);
            Thread t2=new Thread(p);
            t1.setName("线程1");
            t2.setName("线程two");
            t1.start();         //启动线程执行
            t2.start();

        }
}

```



---

# 3、承方式和实现方式的联系与区别





## 【区别】


- 继承 Thread: 线程代码存放 Thread 子类 run 方法中。


- 实现 Runnable ：线程代码存在接口的子类的 run 方法。




## 【实现方法的好处】


1 ）避免了单继承的局限性


2 ）多个线程可以共享同一个接口实现类的对象，非常适合
多个相同线程来处理同一份资源。



---

# 4、Thread类

## 1）构造方法


```javascript
Thread() ：			创建新的 Thread 对象
Thread(String threadname) ：	创建线程并指定线程实例名
Thread(Runnable target) ：	指定创建线程的目标对象，它
实现了 Runnable 接口中的 run 方法
Thread(Runnable target, String name) ：创建新的 Thread 对
象

```

## 2）Thread 类的有关方法 (1)


 void start(): 启动线程，并执行对象的 run() 方法


 run(): 线程在被调度时执行的操作


 String getName(): 返回线程的名称


 void setName(String name): 设置该线程名称


 static currentThread(): 返回当前线程



---

# 5、线程的调度


-  调度策略


-  时间片

![](images/WEBRESOURCE76518d4fd73b0e01fc5ec08101b4dfcd截图.png)

-  抢占式： 高优先级的线程抢占 CPU




-  Java 的调度方法


-  同优先级线程组成先进先出队列（先到先服务），使
用时间片策略


-  对高优先级，使用优先调度的抢占式策略



---

# 6、线程的优先级


-  线程的优先级控制


```javascript
MAX_PRIORITY （ 10 ） ;
MIN _PRIORITY （ 1 ） ;
NORM_PRIORITY （ 5 ） ;
```

-  涉及的方法：


```javascript
getPriority() ：			返回线程优先值
setPriority(int newPriority) ：	改变线程的优先级
 线程创建时继承父线程的优先级
```

## Thread 类的有关方法 (2)


```javascript
 static void yield() ： //线程让步
//*暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
//*若队列中没有同优先级的线程，忽略此方法 

 join() ： 
//*当某个程序执行流中调用其他线程的 join() 方法时，调用
线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止.
//*低优先级的线程也可以获得执行
 
 static void sleep(long millis) ： //( 指定时间 : 毫秒 )
//*令当前活动线程在指定时间段内放弃对 CPU 控制 , 使其他线程有
机会被执行 , 时间到后重排队。
//* 抛出 InterruptedException 异常

 stop(): 		//强制线程生命期结束
 boolean isAlive() ： //返回 boolean ，判断线程是否还活着
```



---

# 7、代码实例

```javascript
/*
 *Thread类的常用方法:
 *  1、start()：启用线程并执行相应的run()方法；
 *  2、run(): 子线程要执行的代码放入run()方法中；
 *  3、currentThread(): 静态的，调取当前的线程
 *  4、setName(): 获取此线程的名字；
 *  5、getName(): 设置此线程的名字；
 *  6、yield():线程释放当前cpu的使用权；
 *  7、join(): 在A线程中调用B线程的join()方法，表示A线程停止执行，直到B线程执行完毕，
 *              A线程在接着执行；
 *  8、isAlive(): 判断当前线程是否还存活，返回值是boolean类型；
 *  9、sleep(ling n): 显示的让当前线程睡眠n毫秒；
 */
```



```javascript
package com.java1;

class SubThread1 extends Thread{     //继承Thread类
    public void run(){              //重写run方法
        for(int i=0;i<=100;i++){
            try {
                Thread.currentThread().sleep(10);       //让子线程睡眠10毫秒

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+Thread.currentThread().getPriority()+" ："+i);
        }
    }

}
public class TestRuns {
    public static void  main(String args[]){    //主线线程，所有的子线程都必须由主线程启用
        SubThread1 subThread1=new SubThread1();
        subThread1.setName("子线程");
        subThread1.setPriority(Thread.MAX_PRIORITY);
        subThread1.start();                      //调用子线程

        Thread.currentThread().setName("=========主线程：");
        for(int i=0;i<=100;i++){
 	  //         System.out.println(Thread.currentThread().getName()+i);
     //           if(i%10==0){
    //                Thread.currentThread().yield();
    //            }
     /*           if(i==20){
                try{
                    subThread1.join();
                }catch (InterruptedException e){
                    e.printStackTrace();
                }*/
            System.out.println(Thread.currentThread().getName()+":"+Thread.currentThread().getPriority()+" : "+i);
            }
        }
}


```

