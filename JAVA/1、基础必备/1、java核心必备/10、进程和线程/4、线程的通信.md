# 1、 wait() 与 notify() 和 notifyAll()


wait() ：令当前线程挂起并放弃 CPU 、同步资源，使别的
线程可访问并修改共享资源，而当前线程排队等候再次
对资源的访问


notify() ：唤醒正在排队等待同步资源的线程中优先级最
高者结束等待


notifyAll () ：唤醒正在排队等待资源的所有线程结束等待 .


 Java.lang.Object 提供的这三个方法只有在 synchronized 方法或
synchronized 代码块中才能使用，否则会报
java.lang.IllegalMonitorStateException 异常

# 


---

# 2、wait() 方法


-  在当前线程中调用方法： 对象名 .wait()


-  使当前线程进入等待（某对象）状态 ，直到另一线程对该
对象发出 notify ( 或 notifyAll) 为止。


-  调用方法的必要条件：当前线程必须具有对该对象的监控
权（加锁）


-  调用此方法后，当前线程将释放对象监控权 ，然后进入
等待


-  在当前线程被 notify 后，要重新获得监控权，然后从断点
处继续代码的执行。




---

# 3、notify()/notifyAll()


 在当前线程中调用方法： 对象名 .notify()


 功能：唤醒等待该对象监控权的一个线程。


 调用方法的必要条件：当前线程必须具有对该对象的监
控权（加锁）




---

# 4、例 题


使用两个线程打印 1-100. 线程 1, 线程 2 交替打印


```javascript
package com.线程通信;
/*
 *线程通信
 * 使用两个线程打印1-100：线程1，线程2交替打印
 * wait():一旦一个线程执行到wait()线程就释放当前的锁；
 * notify()/notifyAll():唤醒wait()的一个或者所有锁；
 */

class PrintNUm implements Runnable{
    int num=1;
    @Override
    public void run() {
        while (true){
            if (num <=100) {
                synchronized (this) {
                    notify();
                    try {
                        Thread.currentThread().sleep(15);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":" + num++);
                    try {
                        wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if(num>=100){
                        notify();
                    }
                }
            }else{
                break;
            }

        }
    }
}
public class TestCommunication {
      public static void main(String args[]){
            PrintNUm p=new PrintNUm();
            Thread t1=new Thread(p);
            Thread t2=new Thread(p);
            t1.setName("甲");
            t2.setName("乙");
            t1.start();
            t2.start();
        }
}

```



---

# 5、经典例题：生产者/消费者

 生产者(Productor)将产品交给店员(Clerk)，而消费者
(Customer)从店员处取走产品，店员一次只能持有固
定数量的产品(比如:20），如果生产者试图生产更多
的产品，店员会叫生产者停一下，如果店中有空位放
产品了再通知生产者继续生产；如果店中没有产品了，
店员会告诉消费者等一下，如果店中有产品了再通知
消费者来取走产品。


 这里可能出现两个问题：


 生产者比消费者快时，消费者会漏掉一些数据没有取
到。




 消费者比生产者快时，消费者会取相同的数据。

```javascript
package com.线程通信;

import org.omg.PortableServer.THREAD_POLICY_ID;

class Cleak{    //店员
    int product;
    public synchronized void addProduct() {
        //生产产品
        if(product>=20){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }else{
            product++;
            System.out.println(Thread.currentThread().getName()+"生产了第" +product+"个产品");
            notifyAll();
        }
    }

    public synchronized void consumerProduct(){//消费产品
        if(product<=0){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        else {
            System.out.println(Thread.currentThread().getName()+"消费了第"+product+"个产品");
            product--;
            notifyAll();
        }
    }
}

class Producer implements Runnable{
    Cleak cleak;
  public Producer(Cleak cleak){
      this.cleak=cleak;
  }
    @Override
    public void run() {
        System.out.println("生产者开始生产产品");
        while (true){
            try {
                Thread.currentThread().sleep(15);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            cleak.addProduct();
        }
    }
}

class Consumer implements Runnable{
    Cleak clerk;
    public Consumer (Cleak cleak){
        this.clerk=cleak;
    }

    @Override
    public void run() {
        System.out.println("消费产品");
        while (true){
            try {
                Thread.currentThread().sleep(15);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumerProduct();
        }
    }
}

public class TestProduceConsume {
      public static void main(String args[]){
              Cleak cleak=new Cleak();
              Producer p1=new Producer(cleak);
              Consumer c1=new Consumer(cleak);
              Thread t1=new Thread(p1);
              Thread t3=new Thread(p1);
              Thread t2 =new Thread(c1);

              t1.setName("生产者1");
              t2.setName("消费者1");
              t3.setName("生产者2");
              t1.start();
              t2.start();
              t3.start();
        }
}

```



---

# 6、模拟银行取钱问题

```javascript
package com.线程通信;

class Account {
    private String accountId;
    private double balance;

    public Account() {

    }

    public Account(String accountId, double balance) {
        this.accountId = accountId;
        this.balance = balance;
    }

    public String getAccountId() {
        return accountId;
    }

    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String toString() {
        return "Account [accountId=" + accountId + ", balance=" + balance + "]";
    }

    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());
        long temp;
        temp = Double.doubleToLongBits(balance);
        result = prime * result + (int) (temp ^ (temp >>> 32));
        return result;
    }

    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Account other = (Account) obj;
        if (accountId == null) {
            if (other.accountId != null) return false;
        } else if (!accountId.equals(other.accountId))
            return false;
        if (Double.doubleToLongBits(balance) != Double.doubleToLongBits(other.balance)) {
            return false;
        }
        return true;
    }
}
  class WithDrawThread extends Thread{
        Account account;
        //要取款的额度
        double withDraw;
        public WithDrawThread(String name,Account account,double amt){
            super(name);
            this.account = account;
            this.withDraw = amt;
        }
        public void run(){
            synchronized (account) {
                if (account.getBalance() > withDraw) {
                    System.out.println(Thread.currentThread().getName()
                            + ":取款成功，取现的金额为：" + withDraw);
                    try {Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();}
                    account.setBalance(account.getBalance() - withDraw);
                } else {
                    System.out.println(" 取现额度超过账户余额，取款失败 ");}
                System.out.println(" 现在账户的余额为： " + account.getBalance());
            }
        }
 }
 
public class Test {
        public static void main(String args[]) {
            Account account = new Account("1234567", 10000);
            Thread t1 = new WithDrawThread("小明", account, 8000);
            Thread t2 = new WithDrawThread("小明'swife", account, 2800);
            t1.start();
            t2.start();
        }
}


```

