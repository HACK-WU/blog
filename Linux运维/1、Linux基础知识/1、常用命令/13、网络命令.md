# **1 ． 配置 IP 地址
**

## **1.1 配置 IP 地址
**

IP 地址是计算机在互联网中唯一的地址编码。每台计算机如果需要接入网络和其他计算机进行数


据通信，就必须配置唯一的公网 IP 地址。


配置 IP 地址有两种方法：


```javascript
1）setup 工具
2）vi /etc/sysconfig/network-scripts/ifcfg-eth0 
#手工修改配置文件
```




## **1.2 重启网络服务
**

```javascript
[root@localhost ~]# service network restart
#重启网络服务
```

## **1.3 虚拟机需要桥接到有线网卡，病重启网络服务
**

## **1.4 复制镜像有可能需要重置 UUID（唯一识别符）
**

```javascript
[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0
#删除 MAC 地址行
[root@localhost ~]# rm -rf /etc/udev/rules.d/70-persistent-net.rules
#删除 MaC 地址和 UUID 绑定文件
[root@localhost ~]# reboot
#重启 Linux
```

# telnet

登录远程主机和管理(测试ip端口是否连通)

## 补充说明

**telnet命令**

### 语法

```bash
telnet(选项)(参数)
```

### 选项

```bash
-8：允许使用8位字符资料，包括输入与输出；
-a：尝试自动登入远端系统；
-b<主机别名>：使用别名指定远端主机名称；
-c：不读取用户专属目录里的.telnetrc文件；
-d：启动排错模式；
-e<脱离字符>：设置脱离字符；
-E：滤除脱离字符；
-f：此参数的效果和指定"-F"参数相同；
-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；
-k<域名>：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；
-K：不自动登入远端主机；
-l<用户名称>：指定要登入远端主机的用户名称；
-L：允许输出8位字符资料；
-n<记录文件>：指定文件记录相关信息；
-r：使用类似rlogin指令的用户界面；
-S<服务类型>：设置telnet连线所需的ip TOS信息；
-x：假设主机有支持数据加密的功能，就使用它；
-X<认证形态>：关闭指定的认证形态。
```

### 参数

- 远程主机：指定要登录进行管理的远程主机；

- 端口：指定TELNET协议使用的端口号。

### 实例

```bash
$ telnet 192.168.2.10
Trying 192.168.2.10...
Connected to 192.168.2.10 (192.168.2.10).
Escape character is '^]'.
    localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1)
login: root
Password:
Login incorrect
```

一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。

```bash
$ telnet 192.168.188.132
Trying 192.168.188.132...
telnet: connect to address 192.168.188.132: Connection refused
telnet: Unable to connect to remote host
```

处理这种情况方法：

1. 确认ip地址是否正确？

1. 确认ip地址对应的主机是否已经开机？

1. 如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看）

1. 如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行）

1. 如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）

# **2 ．ifconfig 命令
**

```javascript
 命令名称：ifconfig。
 英文原意：configure a network interface。
 所在路径：/sbin/ifconfig。
 执行权限：超级用户。
 功能描述：配置网络接口。
```

ifconfig 命令最主要的作用就是查看 IP 地址的信息，直接输入 ifconfig 命令即可。


```javascript
[root@localhost ~]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500
#标志 最大传输单元
inet 192.168.252.20 netmask 255.255.255.0 broadcast 192.168.252.255
#IP 地址 子网掩码 广播地址
inet6 fe80::546e:994b:30c:e2f7 prefixlen 64 scopeid 0x20<link>
#IPv6 地址（目前没有生效）
ether 00:0c:29:aa:d2:96 txqueuelen 1000 (Ethernet)
#MAC 地址
RX packets 3728 bytes 310958 (303.6 KiB)
RX errors 0 dropped 0 overruns 0 frame 0
#接收的数据包情况
TX packets 3051 bytes 1495119 (1.4 MiB)
TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
#发送的数据包情况
lo: flags=73<UP,LOOPBACK,RUNNING> mtu 65536
#本地回环网卡
inet 127.0.0.1 netmask 255.0.0.0
inet6 ::1 prefixlen 128 scopeid 0x10<host>
loop txqueuelen 1000 (Local Loopback)
RX packets 8 bytes 696 (696.0 B)
RX errors 0 dropped 0 overruns 0 frame 0
TX packets 8 bytes 696 (696.0 B)
TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
```

# **3 ．ping 命令
**

ping 是常用的网络命令，主要通过 ICMP 协议进行网络探测，测试网络中主机的通信情况。ping


命令的基本信息如下。

```javascript
 命令名称：ping。
 英文原意：send ICMP ECHO_REQUEST to network hosts。
 所在路径：/bin/ping。
 执行权限：所有用户。
 功能描述：向网络主机发送 ICMP 请求。
```

命令的基本格式如下：


```javascript
[root@localhost ~]# ping [选项] IP
选项：
-b： 后面加入广播地址，用于对整个网段进行探测
-c 次数： 用于指定 ping 的次数
-s 字节： 指定探测包的大小
例子：探测网段中 的 可用主机
在 ping 命令中，可以使用“-b”选项，后面加入广播地址，探测整个网段。我们可以使用这个选
项知道整个网络中有多少主机是可以和我们通信的，而不用一个一个 IP 地址地进行探测。例如：
[root@localhost ~]# ping -b -c 3 192.168.103.255
WARNING: pinging broadcast address
PING 192.168.103.255 (192.168.103.255) 56(84) bytes of data.
64 bytes from 192.168.103.199: icmp_seq=1 ttl=64 time=1.95 ms
64 bytes from 192.168.103.168: icmp_seq=1 ttl=64 time=1.97 ms (DUP!)
64 bytes from 192.168.103.252: icmp_seq=1 ttl=64 time=2.29 ms (DUP!)
…省略部分内容…
# 探测 192.168.103.0/24 网段中有多少可以通信的主机
```

# **4 ．netstat 命令
**

netstat 是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。


在 CentOS 7.x 中 netstat 命令默认没有安装，如果需要使用，需要安装 net-snmp 和 net-tools 软件包。


netstat 命令的基本信息如下。


```javascript
 命令名称：netstat。
 英文原意：Print network connections, routing tables, interface statistics, masquerade connections,
and multicast memberships。
 所在路径：/bin/netstat。
 执行权限：所有用户。
 功能描述：输出网络连接、路由表、接口统计、伪装连接和组播成员。
```

命令格式如下：


```javascript
[root@localhost ~]# netstat [选项]
选项：
-a或--all：显示所有连线中的Socket；
-A<网络类型>或--<网络类型>：列出该网络类型连线中的相关地址；
-c或--continuous：持续列出网络状态；
-C或--cache：显示路由器配置的快取信息；
-e或--extend：显示网络其他相关信息；
-F或--fib：显示FIB；
-g或--groups：显示多重广播功能群组组员名单；
-h或--help：在线帮助；
-i或--interfaces：显示网络界面信息表单；
-l或--listening：显示监控中的服务器的Socket；
-M或--masquerade：显示伪装的网络连线；
-n或--numeric：直接使用ip地址，而不通过域名服务器；
-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；
-o或--timers：显示计时器；
-p或--programs：显示正在使用Socket的程序识别码和程序名称；
-r或--route：显示Routing Table；显示路由表
-s或--statistice：显示网络工作信息统计表；
-t或--tcp：显示TCP传输协议的连线状况；
-u或--udp：显示UDP传输协议的连线状况；
-v或--verbose：显示指令执行过程；
-V或--version：显示版本信息；
-w或--raw：显示RAW传输协议的连线状况；
-x或--unix：此参数的效果和指定"-A unix"参数相同；
--ip或--inet：此参数的效果和指定"-A inet"参数相同。
```

子 例子 1 ：查看本机开启的端口


这是本机最常用的方式，使用选项“-tuln”。因为使用了“-l”选项，所以只能看到监听状态的


连接，而不能看到已经建立连接状态的连接。例如：


```javascript
[root@localhost ~]# netstat -tuln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN
tcp 0 0 0.0.0.0:11211 0.0.0.0:* LISTEN
tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN
tcp 0 0 :::11211 :::* LISTEN
tcp 0 0 :::80 :::* LISTEN
udp 0 0 0.0.0.0:11211 0.0.0.0:*
udp 0 0 :::11211 :::*
# 协议 接收队列 发送队列 本机的 IP 地址及端口号 远程主机的 IP 地址及端口号 状态
```

这个命令的输出较多。


```javascript
 Proto：网络连接的协议，一般就是 TCP 协议或者 UDP 协议。
 Recv-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。
 Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备 ACK
标志的数据包。
 Local Address：本机的 IP 地址和端口号。
 Foreign Address：远程主机的 IP 地址和端口号。
 State：状态。常见的状态主要有以下几种。
- LISTEN：监听状态，只有 TCP 协议需要监听，而 UDP 协议不需要监听。
- ESTABLISHED：已经建立连接的状态。如果使用“-l”选项，则看不到已经建立连接的状态。
- SYN_SENT：SYN 发起包，就是主动发起连接的数据包。
- SYN_RECV：接收到主动连接的数据包。
- FIN_WAIT1：正在中断的连接。
- FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认。
- TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束。
- CLOSED：套接字没有被使用。
在这些状态中，我们最常用的就是 LISTEN 和 ESTABLISHED 状态，一种代表正在监听，另一种
代表已经建立连接。
```

## ** 例子 2 ：查看本机有哪些程序开启的端口
**

如果使用“-p”选项，则可以查看到是哪个程序占用了端口，并且可以知道这个程序的 PID。例


如：


```javascript
[root@localhost ~]# netstat -tulnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 2359/mysqld
tcp 0 0 0.0.0.0:11211 0.0.0.0:* LISTEN 1563/memcached
tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1490/sshd
tcp 0 0 :::11211 :::* LISTEN 1563/memcached
tcp 0 0 :::80 :::* LISTEN 21025/httpd
tcp 0 0 :::22 :::* LISTEN 1490/sshd
udp 0 0 0.0.0.0:11211 0.0.0.0:* 1563/memcached
udp 0 0 :::11211 :::* 1563/memcached
# 比之前的命令多了一个“ -p ”选项，结果多了“ PID/ 程序名”，可以知道是哪个程序占用了端口
```

## **子 例子 3 ：查看所有连接
**

使用选项“-an”可以查看所有连接，包括监听状态的连接（LISTEN）、已经建立连接状态的


连接（ESTABLISHED）、Socket 程序连接等。因为连接较多，所以输出的内容有很多。例如：





```javascript
[root@localhost ~]# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN
tcp 0 0 0.0.0.0:11211 0.0.0.0:* LISTEN
tcp 0 0 117.79.130.170:80 78.46.174.55:58815 SYN_RECV
tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN
tcp 0 0 117.79.130.170:22 124.205.129.99:10379 ESTABLISHED
tcp 0 0 117.79.130.170:22 124.205.129.99:11811 ESTABLISHED
…省略部分内容…
udp 0 0 0.0.0.0:11211 0.0.0.0:*
udp 0 0 :::11211 :::*
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags Type State I-Node Path
unix 2 [ ACC ] STREAM LISTENING 9761 @/var/run/hald/dbus-fr41WkQn1C
…省略部分内容…
```

从“Active UNIX domain sockets”开始，之后的内容就是 Socket 程序产生的连接，之前的内容都是网络服务产生的连接。我们可以在“-an”选项的输出中看到各种网络连接状态，而之前的“-tuln”选项则只能看到监听状态。

## 实例

### **列出所有端口 (包括监听和未监听的)**

```bash
netstat -a     #列出所有端口
netstat -at    #列出所有tcp端口
netstat -au    #列出所有udp端口                             
```

### **列出所有处于监听状态的 Sockets**

```bash
netstat -l        #只显示监听端口
netstat -lt       #只列出所有监听 tcp 端口
netstat -lu       #只列出所有监听 udp 端口
netstat -lx       #只列出所有监听 UNIX 端口
```

### **显示每个协议的统计信息**

```bash
netstat -s   显示所有端口的统计信息
netstat -st   显示TCP端口的统计信息
netstat -su   显示UDP端口的统计信息
```

### **在netstat输出中显示 PID 和进程名称**

```bash
netstat -pt
```

netstat -p

### **在netstat输出中不显示主机，端口和用户名(host, port or user)**

当你不想让主机，端口和用户名显示，使用

```bash
netstat -an
```

如果只是不想让这三个名称中的一个被显示，使用以下命令:

```bash
netsat -a --numeric-ports
netsat -a --numeric-hosts
netsat -a --numeric-users
```

### **持续输出netstat信息**

```bash
netstat -c   #每隔一秒输出网络信息
```

### **显示系统不支持的地址族(Address Families)**

```bash
netstat --verbose
```

在输出的末尾，会有如下的信息：

```bash
netstat: no support for `AF IPX' on this system.
netstat: no support for `AF AX25' on this system.
netstat: no support for `AF X25' on this system.
netstat: no support for `AF NETROM' on this system.
```

### **显示核心路由信息**

```bash
netstat -r
```

使用

### **找出程序运行的端口**

并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。

```bash
netstat -ap | grep ssh
```

找出运行在指定端口的进程：

```bash
netstat -an | grep ':80'
```

### **通过端口找进程ID**

```bash
netstat -anp|grep 8081 | grep LISTEN|awk '{printf $7}'|cut -d/ -f1
```

### **显示网络接口列表**

```bash
netstat -i
```

显示详细信息，像是ifconfig使用

### **IP和TCP分析**

查看连接某服务端口最多的的IP地址：

```bash
netstat -ntu | grep :80 | awk '{print $5}' | cut -d: -f1 | awk '{++ip[$1]} END {for(i in ip) print ip[i],"\t",i}' | sort -nr
```

TCP各种状态列表：

```bash
netstat -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk '/^tcp/ {++state[$NF]} END {for(i in state) print i,"\t",state[i]}'
```

查看phpcgi进程数，如果接近预设值，说明不够用，需要增加：

```bash
netstat -anpo | grep "php-cgi" | wc -l
```

# ss

比 netstat 好用的socket统计信息，iproute2 包附带的另一个工具，允许你查询 socket 的有关统计信息。

## 补充说明

**ss命令**

当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接

天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。

### 语法

```bash
ss [参数]
ss [参数] [过滤]
```

### 选项

```bash
-h, --help      帮助信息
-V, --version   程序版本信息
-n, --numeric   不解析服务名称
-r, --resolve   解析主机名
-a, --all       显示所有套接字（sockets）
-l, --listening 显示监听状态的套接字（sockets）
-o, --options   显示计时器信息
-e, --extended  显示详细的套接字（sockets）信息
-m, --memory    显示套接字（socket）的内存使用情况
-p, --processes 显示使用套接字（socket）的进程
-i, --info      显示 TCP内部信息
-s, --summary   显示套接字（socket）使用概况
-4, --ipv4      仅显示IPv4的套接字（sockets）
-6, --ipv6      仅显示IPv6的套接字（sockets）
-0, --packet    显示 PACKET 套接字（socket）
-t, --tcp       仅显示 TCP套接字（sockets）
-u, --udp       仅显示 UCP套接字（sockets）
-d, --dccp      仅显示 DCCP套接字（sockets）
-w, --raw       仅显示 RAW套接字（sockets）
-x, --unix      仅显示 Unix套接字（sockets）
-f, --family=FAMILY  显示 FAMILY类型的套接字（sockets），FAMILY可选，支持  unix, inet, inet6, link, netlink
-A, --query=QUERY, --socket=QUERY
      QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]
-D, --diag=FILE     将原始TCP套接字（sockets）信息转储到文件
 -F, --filter=FILE  从文件中都去过滤器信息
       FILTER := [ state TCP-STATE ] [ EXPRESSION ]
```

### 实例

```bash
ss -t -a    # 显示TCP连接
ss -s       # 显示 Sockets 摘要
ss -l       # 列出所有打开的网络连接端口
ss -pl      # 查看进程使用的socket
ss -lp | grep 3306  # 找出打开套接字/端口应用程序
ss -u -a    显示所有UDP Sockets
ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有状态为established的SMTP连接
ss -o state established '( dport = :http or sport = :http )' # 显示所有状态为Established的HTTP连接
ss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 193.233.7/24  # 列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字
# ss 和 netstat 效率对比
time netstat -at
time ss
# 匹配远程地址和端口号
# ss dst ADDRESS_PATTERN
ss dst 192.168.1.5
ss dst 192.168.119.113:http
ss dst 192.168.119.113:smtp
ss dst 192.168.119.113:443
# 匹配本地地址和端口号
# ss src ADDRESS_PATTERN
ss src 192.168.119.103
ss src 192.168.119.103:http
ss src 192.168.119.103:80
ss src 192.168.119.103:smtp
ss src 192.168.119.103:25
```

**将本地或者远程端口和一个数比较**

```bash
# ss dport OP PORT 远程端口和一个数比较；
# ss sport OP PORT 本地端口和一个数比较
# OP 可以代表以下任意一个:
# <= or le : 小于或等于端口号
# >= or ge : 大于或等于端口号
# == or eq : 等于端口号
# != or ne : 不等于端口号
# < or gt : 小于端口号
# > or lt : 大于端口号
ss  sport = :http
ss  dport = :http
ss  dport \> :1024
ss  sport \> :1024
ss sport \< :32000
ss  sport eq :22
ss  dport != :22
ss  state connected sport = :http
ss \( sport = :http or sport = :https \)
ss -o state fin-wait-1 \( sport = :http or sport = :https \) dst 192.168.1/24
```

**用TCP 状态过滤Sockets**

```bash
ss -4 state closing
# ss -4 state FILTER-NAME-HERE
# ss -6 state FILTER-NAME-HERE
# FILTER-NAME-HERE 可以代表以下任何一个：
# established、 syn-sent、 syn-recv、 fin-wait-1、 fin-wait-2、 time-wait、 closed、 close-wait、 last-ack、 listen、 closing、
# all : 所有以上状态
# connected : 除了listen and closed的所有状态
# synchronized :所有已连接的状态除了syn-sent
# bucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.
# big : 和bucket相反.
```

**显示ICP连接**

```bash
[root@localhost ~]# ss -t -a
State       Recv-Q Send-Q                            Local Address:Port                                Peer Address:Port
LISTEN      0      0                                             *:3306                                           *:*
LISTEN      0      0                                             *:http                                           *:*
LISTEN      0      0                                             *:ssh                                            *:*
LISTEN      0      0                                     127.0.0.1:smtp                                           *:*
ESTAB       0      0                                112.124.15.130:42071                              42.156.166.25:http
ESTAB       0      0                                112.124.15.130:ssh                              121.229.196.235:33398
```

**显示 Sockets 摘要**

```bash
[root@localhost ~]# ss -s
Total: 172 (kernel 189)
TCP:   10 (estab 2, closed 4, orphaned 0, synrecv 0, timewait 0/0), ports 5
Transport Total     ip        IPv6
*         189       -         -
RAW       0         0         0
UDP       5         5         0
TCP       6         6         0
INET      11        11        0
FRAG      0         0         0
```

列出当前的established, closed, orphaned and waiting TCP sockets

**列出所有打开的网络连接端口**

```bash
[root@localhost ~]# ss -l
Recv-Q Send-Q                                 Local Address:Port                                     Peer Address:Port
0      0                                                  *:3306                                                *:*
0      0                                                  *:http                                                *:*
0      0                                                  *:ssh                                                 *:*
0      0                                          127.0.0.1:smtp                                                *:*
```

**查看进程使用的socket**

```bash
[root@localhost ~]# ss -pl
Recv-Q Send-Q                                          Local Address:Port                                              Peer Address:Port
0      0                                                           *:3306                                                         *:*        users:(("mysqld",1718,10))
0      0                                                           *:http                                                         *:*        users:(("nginx",13312,5),("nginx",13333,5))
0      0                                                           *:ssh                                                          *:*        users:(("sshd",1379,3))
0      0                                                   127.0.0.1:smtp                                                         *:*        us
```

**找出打开套接字/端口应用程序**

```bash
[root@localhost ~]# ss -pl | grep 3306
0      0                            *:3306                          *:*        users:(("mysqld",1718,10))
```

**显示所有UDP Sockets**

```bash
[root@localhost ~]# ss -u -a
State       Recv-Q Send-Q                                     Local Address:Port                                         Peer Address:Port
UNCONN      0      0                                                      *:syslog                                                  *:*
UNCONN      0      0                                         112.124.15.130:ntp                                                     *:*
UNCONN      0      0                                            10.160.7.81:ntp                                                     *:*
UNCONN      0      0                                              127.0.0.1:ntp                                                     *:*
UNCONN      0      0                                                      *:ntp                                                     *:*
```

#### 出所有端口为 22（ssh）的连接

```bash
ss state all sport = :ssh
Netid State      Recv-Q Send-Q     Local Address:Port                      Peer Address:Port
tcp   LISTEN     0      128                    *:ssh                                  *:*
tcp   ESTAB      0      0          192.168.0.136:ssh                      192.168.0.102:46540
tcp   LISTEN     0      128                   :::ssh                                 :::*
```

# **5 ．write 命令
**

write 命令的基本信息如下。


```javascript
 命令名称：write。
 英文原意：send a message to another user。
 所在路径：/usr/bin/write。
 执行权限：所有用户。
 功能描述：向其他用户发送信息。
```

```javascript
[root@localhost ~]#write user1 pts/1
hello
I will be in 5 minutes to restart, please save your data
# 向在 pts/1 （远程终端 1 ）登录的 user1 用户发送信息，使用“ Ctrl+D ”快捷键保存发送的数据
```

# **6 ．wall 命令
**

write 命令用于给指定用户发送信息，而 wall 命令用于给所有登录用户发送信息，包括你自己。


执行时，在 wall 命令后加入需要发送的信息即可，例如：


```javascript
[root@localhost ~]# wall "I will be in 5 minutes to restart, please save your data"
```

# **7 ．mail 命令(****yum install -y mailx****)
**

mail 是 Linux 的邮件客户端命令，可以利用这个命令给其他用户发送邮件。mail 命令的基本信息


如下。


```javascript
 命令名称：mail。
 英文原意：send and receive Internet mail。
 所在路径：/bin/mail。
 执行权限：所有用户。
 功能描述：发送和接收电子邮件。
```

## **子 例子 1 ：发送邮件
**

如果我们想要给其他用户发送邮件，则可以执行如下命令：


```javascript
[root@localhost ~]# mail user1
Subject: hello <- 邮件标题
Nice to meet you! <- 邮件具体内容
. <- 使用“ . ”来结束邮件输入
# 发送邮件给 user1 用户
```

我们接收到的邮件都保存在“

的邮箱。


## **例子 2 ：发送文件内容
**

如果我们想把某个文件的内容发送给指定用户，则可以执行如下命令：


```javascript
[root@localhost ~]# mail -s "test mail" root < /root/anaconda-ks.cfg
选项：
-s： 指定邮件标题
# 把 /root/anaconda-ks.cfg 文件的内容发送给 root 用户
```

我们在写脚本时，有时需要脚本自动发送一些信息给指定用户，把要发送的信息预先写到文件中，


是一个非常不错的选择。


## **例子 3 ：查看已经接收的邮件
**

我们可以直接在命令行中执行 mail 命令，进入 mail 的交互命令中，可以在这里查看已经接收到


的邮件。例如：


```javascript
[root@localhost ~]# mail
Heirloom Mail version 12.4 7/29/08.Type ?for help.
"/var/spool/mail/root": 1 message 1 new
>N 1 root Mon Dec 5 22:45 68/1777 "test mail" <- 之前收到的邮件
>N 2 root Mon Dec 5 23:08 18/602 "hello"
# 未阅读 编号 发件人 时间 标题
& <- 等待用户输入命令
```

可以看到已经接收到的邮件列表，“N”代表未读邮件，如果是已经阅读过的邮件，则前面是不


会有这个“N”的；之后的数字是邮件的编号，我们主要通过这个编号来进行邮件的操作。如果我们


想要查看第一封邮件，则只需输入邮件的编号“1”就可以了。


在交互命令中执行“？”，可以查看这个交互界面支持的命令。例如：


```javascript
& ? <- 输入命令
mail commands
type<message list> type messages
next goto and type next message
from<message list> give head lines of messages
headers print out active message headers
delete<message list> delete messages
undelete<message list> undelete messages
save<message list> folder append messages to folder and mark as saved
copy<message list> folder append messages to folder without marking them
write<message list> file append message texts to file, save attachments
preserve<message list> keep incoming messages in mailbox even if saved
Reply <message list> reply to message senders
reply<message list> reply to message senders and all recipients
mail addresses mail to specific recipients
file folder change to another folder
quit quit and apply changes to folder
xit quit and discard changes made to folder
! shell escape
cd<directory> chdir to directory or home if none given
list list names of all available commands
```

这些交互命令是可以简化输入的，比如“headers”命令，就可以直接输入“h”，这是列出邮件


标题列表的命令。我们解释一下常用的交互命令。


```javascript
 headers：列出邮件标题列表，直接输入“h”命令即可。
 delete：删除指定邮件。比如想要删除第二封邮件，可以输入“d 2”。
 save：保存邮件。可以把指定邮件保存成文件，如“s 2 /tmp/test.mail”。
 quit：退出，并把已经操作过的邮件进行保存。比如移除已删除邮件、保存已阅读邮件等。
 exit：退出，但是不保存任何操作。
```