# **什么是文件描述符？**

[文件描述符](https://so.csdn.net/so/search?q=%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6&spm=1001.2101.3001.7020)是一个简单的正整数，用以标明每一个被进程所打开的文件和socket。

最前面的三个文件描述符（0，1，2）分别与标准输入（[stdin](https://so.csdn.net/so/search?q=stdin&spm=1001.2101.3001.7020)），标准输出（stdout）和标准错误（stderr）对应。

Unix/Linux/BSD 都有三个特别文件，分别

- 1）标准输入 即 STDIN , 在 /dev/stdin ,

一般指键盘输入, shell里代号是

- 2) 标准输出 STDOUT, 在 /dev/stdout,

一般指终端(terminal), 就是显示器, shell里代号是 

- 3) 标准错误 STDERR, 在 /dev/stderr

也是指终端(terminal), 不同的是, 错误信息送到这里

shell里代号是 

# 将标准输出导向到文件, ls 1> log1.txt，缩写就是 ls > log1.txt

```
User@User-PC ~
$ ls 1> log1.txt
 
User@User-PC ~
$ cat log1.txt 
Mail/
News/
a.txt
aa*
awkscr
b.txt
bb*
bin/
cc
cgitest.rex*
dd*
irc-sh*
junk
lib/
log1.txt
lynx.cfg
matrix/
perlscr*
pp*
rexx_script/
rrr
testawk
tmp/
trash
 
```

# 标准错误的演示

```
User@User-PC ~
$ ls llll 1> log2.txt
ls: 无法存取 llll: No such file or directory
 
再次执行，但这次没有这个文件llll, 出现错误讯息
 
User@User-PC ~
$ cat log2.txt 
 
User@User-PC ~
$ file log2.txt
log2.txt: empty
 
输出没有导向到文件，文件是空文件
 
User@User-PC ~
$ ls llll 2> log2.txt
 
User@User-PC ~
$ cat log2.txt 
ls: 无法存取 llll: No such file or directory
 
User@User-PC ~
$ 
 
再次执行刚才的命令，只是将 1> log2.txt 改为 2> log2.txt
这次就成功把错误讯息导向至文件了
```

## 命令 2>&1 > file, 如

```
User@User-PC ~
$ echo 123 | if grep -E '[0-9]+' 2>&1 > /dev/null ; then echo "This is number."; fi
This is number.
```

grep 标准输出和标准错误 都导向到系统‘黑洞’，不会再屏幕上显示什麼

最后再解释一下：

> 默认为标准输出重定向，与 1> 相同

2>&1 意思是把 标准错误输出 重定向到 标准输出.

&>file 意思是把 标准输出 和 标准错误输出 都重定向到文件file中

1.&>file或n>&m均是一个独立的重定向符号，不要分开来理解。

2.明确文件和文件描述符的区别。

3.&>file表示重定向标准输出和错误到文件

例如：

rm -f $(find / -name core) &> /dev/null，/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。

4.n>&m表示使文件描述符n成为输出文件描述符m的副本。这样做的好处是，有的时候你查找文件的时候很容易产生无用的信息,如:2> /dev/null的作用就是不显示标准错误输出；另外当你运行某些命令的时候,出错信息也许很重要,便于你检查是哪出了毛病,如:2>&1

例如：

注意，为了方便理解，必须设置一个环境使得执行grep da *命令会有正常输出和错误输出，然后分别使用下面的命令生成三个文件：

```
grep da * > greplog1
grep da * > greplog2 1>&2   
grep da * > greplog3 2>&1  //grep da * 2> greplog4 1>&2 结果一样
#查看greplog1会发现里面只有正常输出内容
#查看greplog2会发现里面什么都没有
​​​​​​​#查看greplog3会发现里面既有正常输出内容又有错误输出内容
```