# **1、环境变量设置export1**

```javascript
[root@localhost ~]# export age="18"
#使用 export 声明的变量即是环境变量
```

# **2、环境变量查询和删除**

## **1)查询**

- **set | less 命令  （向下翻阅即可找到）**

```javascript
。。。。。
age=18
colors=/root/.dircolors
。。。。。
```

- **env**

```javascript
age=18
MAIL=/var/spool/mail/root
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
PWD=/root
LANG=zh_CN.UTF-8
```

- env 命令和 set 命令的区别是，set 命令可以查看所有变量，而 env 命令只能查看环境变量。

## **2）删除:unsete  环境变量**

```javascript
[root@localhost ~]# unset gender
[root@localhost ~]# env | grep gender
#删除环境变量 gender
```

# **3、系统默认环境变量**

## **1）查看**

# ****

```javascript
[root@localhost ~]# env
HOSTNAME=localhost.localdomain 主机名
SHELL=/bin/bash 当前的 shell
TERM=linux 终端环境
HISTSIZE=1000 历史命令条数
SSH_CLIENT=192.168.4.159 4824 22 当前操作环境是用 ssh 连接的，这里记录客户端 ip
SSH_TTY=/dev/pts/1 ssh 连接的终端时 pts/1
USER=root 当前登录的用户
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;
01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=
01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01

;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=0
1;31:*.bz2=01;31:*.tbz=01;31:*.tbz2=01;31:*.bz=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31
:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.j
pg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga
=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=
01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01
;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35
:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.
flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=0
1;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;3
6:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*
.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:
定义颜色显示
age=18 我们刚刚定义的环境变量
PATH=/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/
root/bin 系统查找命令的路径
MAIL=/var/spool/mail/root 用户邮箱
PWD=/root 当前所在目录
LANG=zh_CN.UTF-8 语系
HOME=/root 当前登录用户的家目录
SHLVL=2 当前在第二层子 shell 中。还记得我们刚刚进入了
一个子 shell 吗？如果是第一层 shell，这里是 1
LOGNAME=root 登录用户
_=/bin/env 上次执行命令的最后一个参数或命令本身
```

- env 命令可以查询到所有的环境变量，可是还有一些变量虽然不是环境变量，却是和 Bash 操作接

口相关的变量，这些变量也对我们的 Bash 操作终端起到了重要的作用。这些变量就只能用 set 命令

来查看了，我只列出重要的内容吧：

```javascript
[root@localhost ~]# set
BASH=/bin/bash Bash 的位置
BASH_VERSINFO=([0]="4" [1]="1" [2]="2" [3]="1" [4]="release"
[5]="i386-redhat-linux-gnu") Bash 版本
BASH_VERSION='4.1.2(1)-release' bash 的版本
COLORS=/etc/DIR_COLORS 颜色记录文件
HISTFILE=/root/.bash_history 历史命令保存文件
HISTFILESIZE=1000 在文件当中记录的历史命令最大条数
HISTSIZE=1000 在缓存中记录的历史命令最大条数
LANG=zh_CN.UTF-8 语系环境
MACHTYPE=i386-redhat-linux-gnu 软件类型是 i386 兼容类型
MAILCHECK=60 每 60 秒去扫描新邮件
PPID=2166 父 shell 的 PID。我们当前 Shell 是一个子 shell
PS1='[\u@\h \W]\$ ' 命令提示符
PS2='> ' 如果命令一行没有输入完成，第二行命令的提示符
UID=0 当前用户的 UID
```

## **2）PATH变量：系统查找命令的路径**

- 先查询下PATH环境变量的值：

```javascript
[root@localhost ~]# echo $PATH
/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/
bin
```

- PATH 变量的值是用“：”分割的路径，这些路径就是系统查找命令的路径。也就是说当我们输入

了一个程序名，如果没有写入路径，系统就会到 PATH 变量定义的路径中去寻找，是否有可以执行的

程序。如果找到则执行，否则会报“命令没有发现”的错误。

那么是不是我们把自己的脚本拷贝到 PATH 变量定义的路径中，我们自己写的脚本也可以不输入

路径而直接运行呢？

```javascript
[root@localhost ~]# cp /root/sh/hello.sh /bin/
#拷贝 hello.sh 到/bin 目录
[root@localhost ~]# hello.sh
Mr. Shen Chao is the most honest man.
#hello.sh 可以直接执行了
```

- 那么我们是不是可以修改 PATH 变量的值，而不是把程序脚本复制到/bin/目录中。当然是可以的，

我们通过变量的叠加就可以实现了：

```javascript
[root@localhost ~]# PATH="$PATH":/root/sh
#在变量 PATH 的后面，加入/root/sh 目录
[root@localhost ~]# echo $PATH
/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/
bin:/root/sh
#查询 PATH 的值，变量叠加生效了
```

当然我们这样定义的 PATH 变量只是临时生效，一旦重启或注销就会消失，如果想要永久生效，

需要写入环境变量配置文件，我们在“环境变量配置文件”小节中再详细介绍。

## **3）PS1变量：命令提示符设置**

- PS1 是一个很有意思的变量（这可不是 SONY 的游戏机哦），是用来定义命令行的提示符的，可以

安装我们自己的需求来定义自己喜欢的提示符。PS1 可以支持以下这些选项：

```javascript
 \d：    显示日期，格式为“星期 月 日”
 \H：    显示完整的主机名。如默认主机名“localhost.localdomain”
 \h：    显示简写主机名。如默认主机名“localhost”
 \t：    显示 24 小时制时间，格式为“HH:MM:SS”
 \T：    显示 12 小时制时间，格式为“HH:MM:SS”
 \A：    显示 24 小时制时间，格式为“HH:MM”
 \@：    显示 12 小时制时间，格式为“HH:MM am/pm”
 \u：    显示当前用户名
 \v：    显示 Bash 的版本信息
 \w：    显示当前所在目录的完整名称
 \W：    显示当前所在目录的最后一个目录
 \#：    执行的第几个命令
 \$：    提示符。如果是 root 用户会显示提示符为“#”，如果是普通用户会显示提示符为

“$”
```

这些选项该怎么用啊？我们先看看 PS1 变量的默认值吧：

```javascript
[root@localhost ~]# echo $PS1
[\u@\h \W]\$
#默认的提示符是显示“[用户名@简写主机名 最后所在目录]提示符”
```

- 在 PS1 变量中，如果是可以解释的符号，如“\u”、“\h”等，则显示这个符号的作用。如果是

不能解释的符号，如“@”或“空格”，则原符号输出。那么我们修改下 PS1 变量，看看会出现社么

情况吧：

```javascript
[root@localhost ~]# PS1='[\u@\t \w]\$ '
#修改提示符为‘[用户名@当前时间 当前所在完整目录]提示符’
[root@04:46:40 ~]#cd /usr/local/src/
#切换下当前所在目录，因为家目录是看不出来区别的
[root@04:47:29 /usr/local/src]#
#看到了吗？提示符按照我们的设计发生了变化
```

- 这里要小心，PS1 变量的值要用单引号包含，否则设置不生效。再举个例子吧：

```javascript
[root@04:50:08 /usr/local/src]#PS1='[\u@\@ \h \# \W]\$'
[root@04:53 上午 localhost 31 src]#
#提示符又变了。\@：时间格式是 HH:MM am/pm；\#：会显示执行了多少个命令
```

- PS1 变量可以自由定制，好像看到了点 Linux 可以自由定制和修改的影子，还是很有意思的。不

过说实话一个提示符已经使用习惯了，如果换一个还是非常别扭的，还是改回默认的提示符吧：

```javascript
[root@04:53 上午 localhost 31 src]#PS1='[\u@\h \W]\$ '
[root@localhost src]#
```

# **4、LANG 语系变量**

- LANG 变量定义了 Linux 系统的主语系环境，这个变量的默认值是：

```javascript
[root@localhost src]# echo $LANG
zh_CN.UTF-8
```

这是因为我们 Linux 安装时，选择的是中文安装，所以默认的主语系变量是“zh_CN.UTF-8”。



- 那么 Linux 中到底支持多少语系呢？我们可以使用以下命令查询：

```javascript
[root@localhost src]# locale -a | more
aa_DJ
aa_DJ.iso88591
aa_DJ.utf8
aa_ER
…省略部分输出…
#查询支持的语系
```

- 

```javascript
[root@localhost src]# locale -a | wc -l
735
#是在太多了，统计一下有多少个吧
```

- 我们支持这么多的语系，当前系统到底是什么语系呢？使用 locale 命令直接查询：

```javascript
[root@localhost src]# locale
LANG=zh_CN.UTF-8
LC_CTYPE="zh_CN.UTF-8"

LC_NUMERIC="zh_CN.UTF-8"
LC_TIME="zh_CN.UTF-8"
LC_COLLATE="zh_CN.UTF-8"
LC_MONETARY="zh_CN.UTF-8"
LC_MESSAGES="zh_CN.UTF-8"
LC_PAPER="zh_CN.UTF-8"
LC_NAME="zh_CN.UTF-8"
LC_ADDRESS="zh_CN.UTF-8"
LC_TELEPHONE="zh_CN.UTF-8"
LC_MEASUREMENT="zh_CN.UTF-8"
LC_IDENTIFICATION="zh_CN.UTF-8"
LC_ALL=
```

- 

- 我们还要通过文件/etc/sysconfig/i18n 定义系统的默认语系，查看下这个文件的内容：

```javascript
[root@localhost src]# cat /etc/sysconfig/i18n
LANG="zh_CN.UTF-8"
```

这又是当前系统语系，又是默认语系，有没有快晕倒的感觉。解释下吧，我们可以这样理解，默

认语系是下次重启之后系统所使用的语系，而当前系统语系是当前系统使用的语系。如果系统重启，

会从默认语系配置文件/etc/sysconfig/i18n 中读出语系，然后赋予变量 LANG 让这个语系生效。也就

是说，LANG 定义的语系只对当前系统生效，要想永久生效就要修改/etc/sysconfig/i18n 文件了。

说到这里，我们需要解释下 Linux 中文支持的问题。是不是我们只要定义了语系为中文语系，如

zh_CN.UTF-8 就可以正确显示中文了呢？这要分情况，如果我们是在图形界面中，或者是使用远程连

接工具（如 SecureCRT），只要正确设置了语系，那么是可以正确显示中文的。当然远程连接工具也

要配置正确的语系环境，具体配置方式可以参考 Linux 系统安装章节。

那么如果是纯字符界面（本地终端 tty1-tty6）是不能显示中文的，因为 Linux 的纯字符界面时

不能显示中文这么复杂的编码的。如果我们非要在纯字符界面显示中文，那么只能安装中文插件，如

zhcon 等。我们举个例子吧：

```javascript
[root@localhost src]# echo $LANG
zh_CN.UTF-8
#我当前使用远程工具连接，只要语系正确，则可以正确显示中文
```

```javascript
[root@localhost src]# df
文件系统 1K-块 已用 可用 已用% 挂载点
/dev/sda3 19923216 1813532 17097616 10% /
tmpfs 312672 0 312672 0% /dev/shm
/dev/sda1 198337 26359 161738 15% /boot
#df 命令可以看到中文是正常的
```