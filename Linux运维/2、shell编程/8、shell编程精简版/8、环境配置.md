**环境配置**

# 1、bash配置文件

- 生效范围分类

- 全局配置：

- /etc/bashrc	

- /etc/profile

- /etc/profile.d/.sh

- 个人配置

- ~/.bash_profile

- ~/.bashrc

- 功能分类

- profile类：为交互式的shell提供配置

- bashrc类：为非交换式的shell提供配置

- shell登录

- 交互式登录：su - USERNAME

- /etc/profile –> /etc/profile.d/.sh –> ~/.bash_profile –> ~/.bashrc –> /etc/bashrc

- 非交换式登录：su USERNAME

- 编辑配置文件定义的新设置的生效方式

- 重新启动shell进程

- 使用source命令

# 2、案例，开机显示系统信息脚本

```
[root@localhost ~]# cat os.sh
#!/bin/bash
yum install -y net-tools &> /dev/null
wangka=`ip a | grep ens | head -1 | cut -d: -f2`
System=$(hostnamectl | grep System | awk '{print $3,$4,$5}')
Kernel=$(hostnamectl | grep Kernel | awk -F: '{print $2}')
Virtualization=$(hostnamectl | grep Virtualization| awk '{print $2}')
Statichostname=$(hostnamectl | grep Static|awk -F: '{print $2}')
Ens32=$(ifconfig $wangka | awk 'NR==2 {print $2}')
Lo=$(ifconfig lo0 | awk 'NR==2 {print $2}')
NetworkIp=$(curl -s icanhazip.com)
echo "当前系统版本是：$System"
echo "当前系统内核是：$Kernel"
echo "当前虚拟平台是：$Virtualization"
echo "当前主机名是：$Statichostname"
echo "当前网卡$wangka的地址是：$Ens32"
echo "当前lo0接口的地址是：$Lo"
echo "当前公网地址是：$NetworkIp"
[root@localhost ~]# bash os.sh
当前系统版本是：CentOS Linux 7
当前系统内核是： Linux 3.10.0-693.el7.x86_64
当前虚拟平台是：vmware
当前主机名是： localhost.localdomain
当前网卡 ens33的地址是：192.168.80.129
当前lo0接口的地址是：127.0.0.1
当前公网地址是：112.4.252.23
```

# 3、案例，监控httpd进程

```
#!/bin/bash
function check_httpd_process_number() {
process_num=`ps -ef | grep httpd| wc -l`
if [ $process_num -gt 50 ];then
 systemctl restart httpd &> /dev/null
  # 重启五次httpd确保服务启动
 systemctl status httpd &> /dev/null
  if [ $? -ne 0 ];then
  num_restart_httpd=0
    while true;do
     let num_restart_httpd++
     systemctl restart httpd &> /dev/null
     systemctl status httpd &> /dev/null
     [ $? -eq 0 ] && break
     [ $num_restart_httpd -eq 6 ] && break
    done
  fi 
  # 判断重启服务的结果
 systemctl status httpd &> /dev/null
 [ $? -ne 0 ] && echo "apache未正常重启，已发送邮件给管理员" && return 1
  sleep 60
return 0
  # 再次判断进程是否正常
  process_num=`ps -ef | grep httpd| wc -l`
  if [ $process_num -gt 50 ] ;then
    echo "apache经过重启进程数依然大于50"
   return 1
  else
   return 0
  fi 
else
  echo "进程数小于50"
  sleep 10
 return 0
fi
}
# 每十秒钟执行一次函数，检查进程是否正常
while true;do
check_httpd_process_number
[ $? -eq 1 ] && exit
done
```

# 4、案例，统计两个目录下的相同文件，以及不同文件

```
#!/bin/bash
# server1的文件在/test/目录中，server2的文件在/root/demo中，通过md5值来判断文件一致
性，最终
# 输出相同文件以及各自的不同文件
point1=0
point2=0
# 将server1上的文件的散列值记录到数组当中
for i in `ls /root/demo`;do
md5=`md5sum /root/demo/$i | awk '{print $1}'`
arrar1[$point1]=$md5:$i
echo ${arrar1[$point1]}
let point1++
done
# 将server2上的文件的散列值记录到数组当中
or i in `ls /test`;do
md5=`md5sum /test/$i | awk '{print $1}'`
arrar2[$point2]=$md5:$i
echo ${arrar2[$point2]}
let point2++
done
# 找出相同文件以及server1上的独立文件
echo "-------------------------------"
for i in ${arrar1[@]};do
for j in ${arrar2[@]};do
temp_flag=0
server1_md5=`echo $i | awk -F: '{print $1}'`
server2_md5=`echo $j | awk -F: '{print $1}'`
server1_filename=`echo $i | awk -F: '{print $2}'`
server2_filename=`echo $j | awk -F: '{print $2}'`
if [ $server1_md5 == $server2_md5 ];then
echo "两边共同文件\t\t\t$server1_filename"
temp_flag=1
break
fi
done
if [ $temp_flag -eq 0 ];then
echo "server1不同文件\t\t\t$i"
fi
done
# 找出server2上的独立文件
for i in ${arrar2[@]};do
for j in ${arrar1[@]};do
temp_flag=0
server1_md5=`echo $i | awk -F: '{print $1}'`
server2_md5=`echo $j | awk -F: '{print $1}'`
server1_filename=`echo $i | awk -F: '{print $2}'`
server2_filename=`echo $j | awk -F: '{print $2}'`
if [ $server1_md5 == $server2_md5 ];then
temp_flag=1
break
fi
done
if [ $temp_flag -eq 0 ];then
echo "server2不同文件\t\t\t$i"
fi
done
```