# 1、把自己的日志加入日志轮替


  这里有两个方法：第一种方法是直接在/etc/logrotate.conf 配置文件中写入该日志的轮替策略，
从而把日志加入轮替；第二种方法是在/etc/logrotate.d/目录中新建立该日志的轮替文件，在该轮
替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可
以把日志加入轮替。我们这里推荐第二种方法，因为系统中需要轮替的日志非常多，如果全都直接写入/etc/logrotate.conf 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。





  说起来很复杂，我们举个例子吧，还记得我们自己生产的/var/log/alert.log 日志吗？这个日志
不是系统默认日志，而是我们通过/etc/rsyslog.conf 配置文件自己生成的日志，所以默认这个日志
是不会轮替的。那么我们需要把这个日志加入日志轮替的策略，该怎么实现呢？我们采用第二种方法，
也就是在/etc/logrotate.d/目录中建立此日志的轮替文件。具体步骤如下：


```javascript
[root@localhost ~]# chattr +a /var/log/alert.log
#先给日志文件赋予 chattr 的 a 属性，保证日志的安全
[root@localhost ~]# vi /etc/logrotate.d/alter
#创建 alter 轮替文件，把/var/log/alert.log 加入轮替
/var/log/alert.log {
weekly 每周轮替一次
rotate 6 保留 6 个轮替日志
sharedscripts 以下命令只执行一次
prerotate 在日志轮替之前执行
/usr/bin/chattr -a /var/log/alert.log
#在日志轮替之前取消 a 属性，以便让日志可以轮替
endscript 脚本结束
sharedscripts
postrotate 在日志轮替之后执行
/usr/bin/chattr +a /var/log/alert.log
#日志轮替之后，重新加入 a 属性
endscript
sharedscripts
postrotate
/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid 2>/dev/null) &>/dev/null
endscript
#重启 rsyslog 服务，保证日志轮替正常
}
```




再举个例子，我们如果需要把 Nginx 服务的日志加入日志轮替，则也需要重启 Nginx 服务，例如：


```javascript
/date/logs/nginx/access/access.log /date/logs/nginx/access/default.log {
#假设 Nginx 的日志放在/date 目录下
daily
rotate 15
sharedscripts
postrotate
/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid) &>/dev/null
#重启 rsyslog 服务
/bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &>/dev/null
#重启 Nginx 服务
endscript
}
```






# 2、logrotate 命令


  我们日志轮替之所以可以在指定的时间备份日志，其实也要依赖系统定时任务。如果大家还记得
/etc/cron.daily/目录，就会发现这个目录中是有 logrotate 文件，logrotate 通过这个文件依赖定
时任务执行的。


  不过 logrotate 命令的格式是什么样的呢？我们来学习下：


```javascript
[root@localhost ~]# logrotate [选项] 配置文件名
选项：
如果此命令没有选项，则会按照配置文件中的条件进行日志轮替
-v： 显示日志轮替过程。加了-v 选项，会显示日志的轮替的过程
-f： 强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置文件中所有
的日志进行轮替
```

我们执行 logrotate 命令，并查看下执行过程：


```javascript
[root@localhost ~]# logrotate -v /etc/logrotate.conf
#查看日志轮替的流程
…省略部分输出…
rotating pattern: /var/log/alert.log weekly (6 rotations)
#这就是我们自己加入轮替的 alert.log 日志。
empty log files are rotated, old logs are removed
considering log /var/log/alert.log
log does not need rotating 时间不够一周，所以不进行日志轮替
…省略部分输出…
```

  我们发现/var/log/alert.log 加入了日志轮替，已经被 logrotate 识别，并调用了。只是时间没
有达到轮替的标准，所以没有进行轮替。那我们强制进行一次日志轮替，看看有什么结果：


```javascript
[root@localhost ~]# logrotate -vf /etc/logrotate.conf
#强制进行日志轮替，不管是否符合轮替条件
…省略部分输出…
rotating pattern: /var/log/alert.log forced from command line (6 rotations)
empty log files are rotated, old logs are removed
considering log /var/log/alert.log
log needs rotating 日志需要轮替
rotating log /var/log/alert.log, log->rotateCount is 6
dateext suffix '-20180607' 提取日期参数
glob pattern '-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'
glob finding old rotated logs failed
running prerotate script
fscreate context set to unconfined_u:object_r:var_log_t:s0
renaming /var/log/alert.log to /var/log/alert.log-20180607
#旧的日志被重命名
creating new /var/log/alert.log mode = 0600 uid = 0 gid = 0
#创建新日志文件，同时制定权限、所有者和属组
running postrotate script
…省略部分输出…
```

我们发现 alert.log 日志已经完成了日志轮替。我们查看下新产生的日志和旧日志：


```javascript

[root@localhost ~]# ll /var/log/alert.log*
-rw-------. 1 root root 0 6 月 7 10:07 /var/log/alert.log
-rw-------. 1 root root 237 6 月 7 09:58 /var/log/alert.log-20180607
#旧日志文件已经转储
[root@localhost ~]# lsattr /var/log/alert.log
-----a-------e- /var/log/alert.log
#新的日志文件被自动加入了 chattr 的 a 属性。
```

logrotate 命令使用“-f”选项之后，就不管日志是否已经符合了日志轮替条件，而强制把所有
的日志都进行了轮替。