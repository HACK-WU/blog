# **1 vmstat 检测系统的资源变化**

**（vmstat,v，**

```javascript
[root@server1 ~]# vmstat --help
Usage(用法):
 vmstat [options] [delay [count]]
[root@localhost ~]# vmstat [刷新延时 刷新次数]
[root@localhost ~]# vmstat	[-a]	  #CPU/内存等信息
[root@localhost ~]# vmstat	[-fs]	  #内存相关
[root@localhost ~]# vmstat	[-S 单位] #设置显示数据的单位
[root@localhost ~]# vmstat [-d]	  #与磁盘相关
[root@localhost ~]# vmstat	[-p 分区]  #与磁盘相关
选型与参数：
    -a:使用inactive/active(活动与否)替换buffer/cache的内存输出信息
    -f:开机到目前为止，系统复制(fork)的进程数。
    -s:将一些事件（启动至目前为止）导致的内存变化情况列表说明
    -d:列出磁盘的读写总量统计表。
    -p:后面列出分区，可显示该分区的读写总量统计表

```

例如：


```javascript
[root@localhost proc]# vmstat 1 3
#使用 vmstat 检测，每 1 秒刷新一次，共刷新 3 次
[root@server1 ~]# vmstat 1 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id  wa st
 1  0      0 1558432   2108 181296   0    0     2     0    8   10  0  0 100  0  0
 0  0      0 1558424   2108 181328   0    0     0     0   29   25  0  0 100  0  0
 0  0      0 1558424   2108 181328   0    0     0     0   17   20  0  0 100  0  0
```

解释下这个命令的输出：


```javascript
 procs：进程信息字段：
     r：等待运行的进程数，数量越大，系统越繁忙。
     b：不可被唤醒的进程数量，数量越大，系统越繁忙。
 memory：内存信息字段：
     swpd：虚拟内存的使用情况，单位 KB。
     free：空闲的内存容量，单位 KB。
     buff：缓冲的内存容量，单位 KB。
     cache：缓存的内存容量，单位 KB。
 swap：交换分区的信息字段：
     si：(si,swap,in,进入内存)从磁盘中交换到内存中数据的数量，单位 KB。
     so：(so,swap,out,从内存出来)从内存中交换到磁盘中数据的数量，单位 KB。此两个数越大，证明数据需要经常在
 		 磁盘和内存之间交换，系统性能越差。
 io：磁盘读写信息字段：
     bi：(block in)从块设备读入数据的总量，单位是块。
     bo：(block out)写到块设备的数据的总量，单位是块。此两个数越大，代表系统的 I/O 越繁忙。
 system：系统信息字段：
     in：(interrupt,中断)每秒被中断的进程次数。
     cs：(case,sum,事件改变次数)每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。
 CPU：CPU 信息字段：
     us：(unsystem,非系统，非内核)非内核进程消耗 CPU 运算时间的百分比。
     sy：(system,)内核进程消耗 CPU 运算时间的百分比。
     id：(idle,空闲)空闲 CPU 的百分比。
     wa：(wait,等待)等待 I/O 所消耗的 CPU 百分比。
     st：(stand,忍受，占用)被虚拟机所盗用的 CPU 占比。
```

## **vmstat -d ,查看磁盘的读写总量统计表**

```javascript
[root@server1 ~]# vmstat -d
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
sr0       18      0    2056      40      0      0       0       0      0      0
sdb      376      0   18735     127      4      0    4096      23      0      0
sda     4746      1  256185    2566    540    134   23770     516      0      2
dm-0    2524      0  191424    1824    664      0   19633     660      0      1
dm-1      90      0    4920      26      0      0       0       0      0      0
dm-2      43      0    2072       9      0      0       0       0      0      0
```

## **vmstat -p /dev/sda1  查看分区的磁盘的读写总量表**

```javascript
[root@server1 ~]# vmstat -p /dev/sda1
sda1          reads   read sectors  writes    requested writes
                2042      52257         10       4137
```

# **2 dmesg 显示开机时内核检测信息
**

**（英文全称：display message）命令用于显示开机信息。**

**kernel 会将开机信息存储在 ring buffer 中。您若是开机时来不及查看信息，可利用 dmesg 来查看。开机信息亦保存在 /var/log 目录中，名称为 dmesg 的文件里**

例如：


```javascript
[root@localhost ~]# dmesg | grep CPU
#查看 CPU 信息
[root@localhost ~]# dmesg | grep eth0
#查询第一块网卡信息
[root@localhost ~]# dmesg 
。。。
ci 0000:00:15.7: PCI bridge to [bus 0a-0a]
pci 0000:00:15.7:   bridge window [mem 0xfb800000-0xfb8fffff]
pci 0000:00:15.7:   bridge window [mem 0xe5e00000-0xe5efffff 64bit pref]
pci 0000:00:16.0: PCI bridge to [bus 0b-0b]
pci 0000:00:16.0:   bridge window [io  0x5000-0x5fff]
pci 0000:00:16.0:   bridge window [mem 0xfd300000-0xfd3fffff]
pci 0000:00:16.0:   bridge window [mem 0xe7900000-0xe79fffff 64bit pref]
pci 0000:00:16.1: PCI bridge to [bus 0c-0c]
pci 0000:00:16.1:   bridge window [io  0x9000-0x9fff]
。。。。。。
 [root@bogon proc]# dmesg  |  grep CPU
SMP: Allowing 128 CPUs, 127 hotplug CPUs
NR_CPUS:4096 nr_cpumask_bits:128 nr_cpu_ids:128 nr_node_ids:1
PERCPU: Embedded 31 pages/cpu @ffff88000c400000 s96600 r8192 d22184 u131072
CPU: Physical Processor ID: 0
mce: CPU supports 0 MCE banks
CPU0: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz stepping 01
CPUID marked event: 'cpu cycles' unavailable
CPUID marked event: 'instructions' unavailable
CPUID marked event: 'bus cycles' unavailable
CPUID marked event: 'cache references' unavailable
CPUID marked event: 'cache misses' unavailable
CPUID marked event: 'branch instructions' unavailable
CPUID marked event: 'branch misses' unavailable
Brought up 1 CPUs
microcode: CPU0 sig=0x806c1, pf=0x1, revision=0xffffffff
```

# **3 free 命令查看内存使用状态
**

```javascript
[root@localhost ~]# free [-b|-k|-m|-g]
选项：
-b： 以字节为单位显示
-k： 以 KB 为单位显示，默认就是以 KB 为单位显示
-m： 以 MB 为单位显示
-g： 以 GB 为单位显示
```

**free -h 查看内存使用情况**

```javascript
[root@server1 ~]# free -h
              total        used        free      shared  buff/cache   available
Mem:           1.8G        102M        1.5G        9.6M        179M        1.5G
Swap:          2.0G          0B        2.0G
```

解释下这个命令：


```javascript
第一行：total 是总内存数，used 是已经使用的内存数，free 是空闲的内存数，shared 是多个
       进程共享的内存总数，buffers 是缓冲内存数，cached 是缓存内存数。默认单位是 KB。
第二行：-/buffers/cache 的内存数，相当于第一行的 used-buffers-cached。+/buffers/cache
        的内存数，相当于第一行的 free+buffers+cached。
第三行：total 是 swap 的总数；used 是已经使用的 swap 数，free 是空闲的 swap 数。默认单位是 KB。
```

# **4 查看 CPU 信息
**

CPU 的主要信息保存在/proc/cpuinfo 这个文件当中，我们只要查看这个文件，就可以知道 cpu


的相关信息。命令如下：


```javascript
[root@localhost ~]# cat /proc/cpuinfo
processor : 0		#逻辑 CPU 编号
vendor_id : GenuineIntel	#CPU 制造厂商
cpu family : 6		#产品的系列代号
model : 58			#CPU 系列代号
model name : Intel(R) Core(TM) i7-3630QM CPU @ 2.40GHz	#CPU 系列的名字，编号，主频
stepping : 9		#更新版本
cpu MHz : 2394.649		#实际主频
cache size : 6144 KB	#二级缓存
```

# **5 查看本机登陆用户信息
**

如果我们想要知道 Linux 服务器上目前已经登录的用户信息，可以使用 w 或 who 命令来进行查询。


先看看 w 命令，命令格式如下：


```javascript
[root@server1 ~]# w
 11:44:37 up  3:08,  2 users,  load average: 0.01, 0.04, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1                      08:37    3:07m  0.02s  0.02s -bash
root     pts/0    192.168.10.1     08:37    5.00s  0.16s  0.01s w
```

解释下这个命令的结果：


```javascript
 第一行其实和 top 命令的第一行非常类似，主要显示了系统当前时间，开机多久（up），有
  多少用户登陆（users），1 分钟、5 分钟、15 分钟前的平均负载（load average）。
 第二行是项目的说明，第三行开始每行代表一个用户。这些项目是：
  USER：登陆的用户名；
  TTY：登陆终端；
  FROM：从哪个 IP 地址登陆；
  LOGIN@：登陆时间；
  IDLE：用户闲置时间；
  JCPU：指的是和该终端连接的所有进程占用的 CPU 运算时间。这个时间里并不包括过去
        的后台作业时间，但却包括当前正在运行的后台作业所占用的时间；
  PCPU：是指当前进程所占用的 CPU 运算时间；
  WHAT：当前正在运行的命令。
```

who 命令比 w 命令稍微简单一点，也可以用来查看系统中已经登录的用户。命令如下：


```javascript
[root@server1 ~]# who
root     tty1         2022-01-27 08:37
root     pts/0        2022-01-27 08:37 (192.168.10.1)
#用户名  登录终端      登录时间（登录来源 IP 地址） 
```

# **6 uptime 命令（up time 登录时间）
**

uptime 命令的作用就是显示系统的启动时间和平均负载，也就是 top 命令的第一行。其实 w 命令


也能看到这一行的数据，具体原意使用哪个命令看个人习惯。命令如下：


```javascript
[root@localhost ~]# uptime
10:56:30 up 10:52, 2 users, load average: 0.00, 0.00, 0.00
```

# **7 uname查看系统与内核相关信息,****（英文全拼：unix name）命令用于显示系统信息。**

**uname 可显示电脑以及操作系统的相关信息。**

我们使用 uname 命令查看内核的相关信息，命令如下：


```javascript
[root@localhost ~]# uname [选项]
选项：
-a： 查看系统所有相关信息；
-r： 查看内核版本；
-s： 查看内核名称。
-m:  本系统的硬件架构。
-p:  CPU类型
-i:  硬件的平台(x86)
```

**uname  -a  查看系统的内核信息**

```javascript
[root@server1 ~]# uname -a
Linux server1 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
[root@server1 ~]# uname -r
3.10.0-957.el7.x86_64
[root@server1 ~]# uname -s
Linux
```

如果我们想要判断当前系统的位数，可以通过 file 命令来判断系统文件（主要是系统命令）的


位数来推断系统的位数。命令如下：

**file  /bin/ls 查看系统的位数**

```javascript
[root@server1 ~]# file /bin/ls
/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), 
for GNU/Linux 2.6.32, BuildID[sha1]=ceaf496f3aec08afced234f4f36330d3d13a657b, stripped
#很明显，当前系统是 64位的。
```

如果我们想要查询当前 Linux 系统的发行版本，可以使用“lsb_release -a”命令查看，命令如


下：


```javascript
[root@localhost ~]# lsb_release -a
```

# **8、netstat:追踪网络或socket文件**

(net:worknet,网络；stat：状态）

```javascript
[root@localhost ~]# netstat -[atunlp] 
选项与参数：
    -a:(all,所有)将目前系统上所有的连接、监听、socket信息都列出来
    -t:(TCP,传输控制协议),列出tcp网络封包的信息。
    -u:(UDP),列出udp网络封包的信息。
    -n:(port number)以端口号来显示
    -p:(PID)列出网络服务进程的PID
```

## **netstat 命令**

```javascript
[root@server1 ~]# netstat 
Active Internet connections (w/o servers)		#与网络相关的部分
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 bogon:ssh               bogon:49351             ESTABLISHED
tcp        0     36 bogon:ssh               bogon:49324             ESTABLISHED
tcp        0      0 bogon:52362             59.111.0.251:http       TIME_WAIT  
tcp        0      0 bogon:33182             linux.dgut.edu.cn:http  TIME_WAIT  
tcp        0      0 bogon:33186             linux.dgut.edu.cn:http  TIME_WAIT  
Active UNIX domain sockets (w/o servers)		#与本机进程的相关性（非网络）
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ]         DGRAM                    33605    /var/run/chrony/chronyd.sock
unix  3      [ ]         DGRAM                    2221     /run/systemd/notify
unix  2      [ ]         DGRAM                    2223     /run/systemd/cgroups-agent
unix  2      [ ]         DGRAM                    19122    /run/systemd/shutdownd
unix  5      [ ]         DGRAM                    2238     /run/systemd/journal/socket
unix  15     [ ]         DGRAM                    2240     /dev/log
unix  3      [ ]         STREAM     CONNECTED     40059    
unix  2      [ ]         DGRAM                    36584    
```

上面的显示结果分为两部分，分别是

**因特网连接字段**

```javascript
Proto: 网络的封包协议，主要分为TCP和UDP封包，相关数据请参考服务器篇。
Recv-Q: 非用户进程连接到此socket的复制的总Bytes数；
Send-Q: 非由远程主机传送过来的acknowledge总Byte数；
Local Address: 本地端的IP:port情况；
Foreign Address: 远程主机的IP:port情况；
State: 连接状态，主要有建立(ESTABLISED)及监听(LISTEN);
```

**socke 文件输出字段：**

```javascript
Proto: 一般就是Unix；
RefCnt: 连接到此socket的进程数量；
Flags: 连接的标志；
Type:socket存取文件的类型。主要有确认连接的STREMA与不需确认的DGRAM两种；
State:若为CONNECTED则表示多进程之间已经建立连接；
Path:连接到此socket的相关进程的路径，或是相关数据输出路径。
```

**netstat  -tunpl:**

```javascript
[root@server1 ~]# netstat -tunpl
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      6649/sshd           
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      6888/master         
tcp6       0      0 :::22                   :::*                    LISTEN      6649/sshd           
tcp6       0      0 ::1:25                  :::*                    LISTEN      6888/master         
udp        0      0 0.0.0.0:68              0.0.0.0:*                           7617/dhclient       
udp        0      0 127.0.0.1:323           0.0.0.0:*                           6387/chronyd        
udp6       0      0 ::1:323                 :::*                                6387/chronyd   
```