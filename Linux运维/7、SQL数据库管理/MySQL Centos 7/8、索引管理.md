**索引管理**

# 1、索引介绍

## 1）功能

```
1. 索引的功能就是加速查找
2. mysql中的primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束
的功能
```

## 2）常用索引

```
普通索引INDEX：加速查找
唯一索引：
-主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）
-唯一索引UNIQUE:加速查找+约束（不能重复）
联合索引：
-PRIMARY KEY(id,name):联合主键索引
-UNIQUE(id,name):联合唯一索引
-INDEX(id,name):联合普通索引
```

## 3）索引类型

```
#我们可以在创建上述索引的时候，为其指定索引类型，分两类
hash类型的索引：查询单条快，范围查询慢
btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）
#不同的存储引擎支持的索引类型也不一样
InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 #方法一：创建表
时
CREATE TABLE 表名 (
字段名1 数据类型 [完整性约束条件…],
字段名2 数据类型 [完整性约束条件…],
[UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY
[索引名] (字段名[(长度)] [ASC |DESC])
);
#方法二：CREATE在已存在的表上创建索引
CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名
ON 表名 (字段名[(长度)] [ASC |DESC]) ;
#方法三：ALTER TABLE在已存在的表上创建索引
ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX
索引名 (字段名[(长度)] [ASC |DESC]) ;
#删除索引：DROP INDEX 索引名 ON 表名字; 索引；
MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；
```

# 2、索引使用

## 1）创建/删除索引语法

```
#方法一：创建表时
CREATE TABLE 表名 (
字段名1 数据类型 [完整性约束条件…],
字段名2 数据类型 [完整性约束条件…],
[UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY
[索引名] (字段名[(长度)] [ASC |DESC])
);
#方法二：CREATE在已存在的表上创建索引
CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名
ON 表名 (字段名[(长度)] [ASC |DESC]) ;
#方法三：ALTER TABLE在已存在的表上创建索引
ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX
索引名 (字段名[(长度)] [ASC |DESC]) ;
#删除索引：DROP INDEX 索引名 ON 表名字;
```

## 2）创建/删除索引示例

```
#方式一
create table t1(
id int,
name char,
age int,
sex enum('male','female'),
unique key uni_id(id),
index ix_name(name) #index没有key
);
create table t1(
id int,
name char,
age int,
sex enum('male','female'),
unique key uni_id(id),
index(name) #index没有key
);
#方式二
create index ix_age on t1(age);
#方式三
alter table t1 add index ix_sex(sex);
alter table t1 add index(sex);
#查看
mysql> show create table t1;
| t1 | CREATE TABLE `t1` (
`id` int(11) DEFAULT NULL,
`name` char(1) DEFAULT NULL,
`age` int(11) DEFAULT NULL,
`sex` enum('male','female') DEFAULT NULL,
UNIQUE KEY `uni_id` (`id`),
KEY `ix_name` (`name`),
KEY `ix_age` (`age`),
KEY `ix_sex` (`sex`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
```

## 3）测试索引

```
#1. 准备表
create table s1(
id int,
name varchar(20),
gender char(6),
email varchar(50)
);
#2. 创建存储过程，实现批量插入记录
delimiter $$ #声明存储过程的结束符号为$$
create procedure auto_insert2()
BEGIN
declare i int default 1;
while(i<3000000)do
insert into s1 values(i,'eva','female',concat('eva',i,'@eagleslab'));
set i=i+1;
end while;
END$$ #$$结束
delimiter ; #重新声明分号为结束符号
#3. 查看存储过程
show create procedure auto_insert2\G
#4. 调用存储过程
call auto_insert2();
#没有索引
select * from s1 where id=333333333;
#建立索引
create index a on s1(id);
#查询测试
select * from s1 where id=333333333;
#补充
1.mysql先去索引表里根据b+树的搜索原理很快搜索到id等于333333333的记录不存在，IO大大降
低，因而速度明
显提升
2.我们可以去mysql的data目录下找到该表，可以看到占用的硬盘空间多了
3.如果我们通过email查询，速度依旧很慢，因为没有对eamil创建索引
```

# 3、SQL模型

- ANSI QUOTES：：宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调

整或截断保存，报warning警告。 双引号相当于反引号，只可以引用表名等字段名称，字符串只可

以使用单引号引用；

- IGNORE_SPACE：在内建函数中忽略多余的空白字符；

- STRICT_ALL_TABLES：如果没有设置这个值，非法的数据都允许存入，但是会有一个警告提示。如

果设置了，所有非法的数据都不允许填入，并且返回一个错误；

STRICT_TRANS_TABLES：向一个支持事务的表中插入非法数据的时候不允许，并且返回一个错误；

- TRADITIONAL：严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不

能插入，报error错误。用于事物时，会进行事物的回滚

**如何查看并修改sql模型？**

```
SELECT @@[GLOBAL | SESSION].sql_mode;  显示值
set GLOBAL | SESSION sql_mode=[值];  修改值
```

# 4、优化性能

## 1)总结

```
1. 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333;就需要为id加上索引
2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快
    比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，
    存放于硬盘的表中。建完以后，再查询就会很快了。
3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYI
    MySAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照
    B+Tree（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索
    引的key是数据表的主键，因此innodb表数据文件本身就是主索引。
    因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果
    没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为
    innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型.
```

## 2）正确使用索引

- 并不是说我们创建了索引就一定会加快查询速度，若想利用索引达到预想的提高查询速度的效

果，我们在添加索引 时，必须遵循以下问题

- 范围问题，或者说条件不明确，条件中出现这些符号或关键字：>、>=、<、<=、!= 、between…and…、like

- 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count()，表示字段不重
复的比例，比例越大 我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可
能在大数据面前区分度就是0，那可能有人 会问，这个比例有什么经验值吗？使用场景不同，
这个值也很难确定，一般需要join的字段我们都要求是0.1以上， 即平均1条扫描10条记录


- 索引列不能在条件中参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-
29’就不能使用到 索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需
要把所有元素都应用函数才能比较，显 然成本太大。所以语句应该写成create_time =unix_timestamp(’2014-05-29’)


- 最左前缀匹配原则（详见第八小节），非常重要的原则，对于组合索引mysql会一直向右匹配
直到遇到范围查询 (>、<、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，
比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以 任意调整。


## 3)注意事项（有很多可以优化MySQL，以下只是部分操作）


- 避免使用select * ‐ 使用count()

- 创建表时尽量使用 char 代替 varchar

- 表的字段顺序固定长度的字段优先

- 组合索引代替多个单列索引（由于mysql中每次只能使用一个索引，所以经常使用多个条件查

询时更适合使用组 合索引）

- 尽量使用短索引

- 使用连接（JOIN）来代替子查询(Sub‐Queries)

- 连表时注意条件类型需一致

- 索引散列值（重复少）不适合建索引，例：性别不适合