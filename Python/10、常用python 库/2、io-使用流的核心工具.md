# 16.2. io - 使用流的核心工具

**源代码：**

## 16.2.1. 概览

io

独立于其类别，每个具体的流对象也将具有各种能力：它可以是只读的，只写的或读写的。它还可以允许任意随机存取（寻找向前或向后到任何位置），或只允许顺序存取（例如在套接字或管道的情况下）。

所有流都仔细考虑您给他们的数据类型。例如，给二进制流的

在版本3.3中已更改：由于

### 16.2.1.1. 文本 I/O

文本I / O期望并生成

创建文本流的最简单方法是使用

```python
f = open("myfile.txt", "r", encoding="utf-8")
```

内存中的文本流也可用作

```python
f = io.StringIO("some initial text data")
```

文本流API在

### 16.2.1.2. 二进制I / O

二进制I / O（也称为

创建二进制流的最简单方法是在模式字符串中使用

```python
f = open("myfile.jpg", "rb")
```

内存中的二进制流也可用作

```python
f = io.BytesIO(b"some initial binary data: \x00\x01")
```

二进制流API在

其他库模块可以提供用于创建文本或二进制流的附加方式。例如，请参见

### 16.2.1.3. 原始I/O

原始I / O（也称为

```python
f = open("myfile.jpg", "rb", buffering=0)
```

原始流API在

## 16.2.2. 高级模块接口

io.

包含由模块的缓冲I / O类使用的默认缓冲区大小的int。

io.

这是内置

**exception **

这是内置

**exception **

在流上调用不受支持的操作时引发的异常,继承了

### 16.2.2.1. 内存中的流

也可以使用

也可以看看

sys

包含标准IO流：

## 16.2.3. 类的层次

I / O流的实现被组织为类的层次结构。第一个

> 注意抽象基础类也提供某些方法的默认实现为了有助于实现具体流类. 例如, BufferedIOBase提供非优化的实现readinto() 和readline().


在I / O层次结构的顶部是抽象基类

RawIOBase

BufferedIOBase

TextIOBase

参数名称不是规范的一部分，只有

下表总结了由

| 抽象基类 | 继承 | 存根方法 | Mixin方法和属性 | 
| -- | -- | -- | -- |
|   |   | fileno | close | 
|   |   | readinto | 继承 | 
|   |   | detach | 继承 | 
|   |   | detach | 继承了 | 


### 16.2.3.1. I/O基础类

**class **

所有I / O类的抽象基类，作用于字节流。没有公共构造函数。这个类为许多方法提供了空的抽象实现，派生类可以有选择地重写；默认实现表示不能读取，写入或查找的文件。即使

**class **

原始二进制I / O的基类。它继承

**class **

支持某种缓冲的二进制流的基类。它继承

### 16.2.3.2. 原始文件I/O

**class **

FileIO

### 16.2.3.3. 缓冲流

缓冲I / O流为I / O设备提供了比原始I / O更高级别的接口。

**class **

使用内存中字节缓冲区的流实现。它继承

**class **

一个提供对可读，顺序

**class **

一个缓冲区，提供对可写入的顺序

**class **

缓冲接口，用于随机访问流。它继承

**class **

缓冲I / O对象将两个单向

### 16.2.3.4. 文本 I/O

**class **

文本流的的基类。此类提供一个字符和网格线的基于的界面流 i/o。这里没有 

**class **

在 

**class **

用于文本I / O的内存中流。当调用

**class**

辅助编解码器，用于解码

## 16.2.4. 性能

本节讨论提供的具体I / O实现的性能。

### 16.2.4.1. 二进制I / O

通过只读取和写入大量数据，即使用户请求单个字节，缓冲I / O隐藏了调用和执行操作系统的未缓冲I / O例程的任何低效率。增益取决于OS和执行的I / O的种类。例如，在某些现代操作系统（如Linux）上，无缓冲磁盘I / O可以与缓冲I / O一样快。然而，底线是缓冲I / O提供可预测的性能，而不管平台和后备设备。因此，对于二进制数据，几乎总是优选使用缓冲I / O而不是无缓冲I / O。

### 16.2.4.2. 文本I / O

二进制存储（例如文件）上的文本I / O比同一存储上的二进制I / O慢得多，因为它需要使用字符编解码器在Unicode和二进制数据之间进行转换。这可以变得明显处理大量的文本数据，如大日志文件。此外，由于使用重构算法，

StringIO

### 16.2.4.3. 多线程

FileIO

二进制缓冲对象（

TextIOWrapper

### 16.2.4.4. 重入

二进制缓冲对象（

上面隐含地扩展到文本文件，因为