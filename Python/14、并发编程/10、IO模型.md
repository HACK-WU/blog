# 1、IO模型简介

```shell
"""
我们这里研究的IO模型都是针对网络IO的
Stevens在文章中一共比较了五种IO Model：
    * blocking IO           阻塞IO
    * nonblocking IO      非阻塞IO
    * IO multiplexing      IO多路复用
    * signal driven IO     信号驱动IO
    * asynchronous IO    异步IO
    由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。
"""
#1）等待数据准备 (Waiting for the data to be ready)
#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)
​
同步异步
阻塞非阻塞
常见的网络阻塞状态:
    accept
    recv
    recvfrom
    
    send虽然它也有io行为 但是不在我们的考虑范围
```

# 2、阻塞IO模型

```shell
"""
我们之前写的都是阻塞IO模型  协程除外
"""
import socket
​
​
server = socket.socket()
server.bind(('127.0.0.1',8080))
server.listen(5)
​
​
while True:
    conn, addr = server.accept()
    while True:
        try:
            data = conn.recv(1024)
            if len(data) == 0:break
            print(data)
            conn.send(data.upper())
        except ConnectionResetError as e:
            break
    conn.close()
    
# 在服务端开设多进程或者多线程 进程池线程池 其实还是没有解决IO问题    
该等的地方还是得等 没有规避
只不过多个人等待的彼此互不干扰
```

# 3、非阻塞IO

```python
#要自己实现一个非阻塞IO模型
import time
import socket
phone=socket.socket()
phone.bind(("127.0.0.1",8080))
phone.listen(5)
phone.setblocking(False)            #将所有的网络阻塞变为非阻塞
conn_list=[]
del_list=[]
def communtcaion(conn_list):
    for conn in conn_list:        #循环对连接对象进行处理
        try:    
            data=conn.recv(1024)
        """
        conn.recv() 也是属于网络IO，所以现在如果没有客户端的消息，也不会进行阻塞，同理也会抛出一个异常：BlockingIOError。
        如果恰巧接收到了数据，直接对数据进行处理就行了。
        """
            if len(data)==0:
                conn.close()
                del_list.append(conn)        #收空，证明这个连接对象出现了异常，放入到准备删除的队列中，后面在进行处理。
                continue                #然后直接处理下一个连接对象
            print(data.decode("utf-8"))
            conn.send(data.upper())
        except BlockingIOError:        #捕获到这个异常，证明还没有接收到客户端的数据，啥也不做，直接处理下一个连接对象即可。
            continue
        except ConnectionResetError as e :    
            print(e)
            conn.close()
            del_list.append(conn)        #此链接已经断开，加入到要删除的队列中，稍后处理
    for conn in del_list:        #将要删除的连接对象，从conn_list队列中删除
        conn_list.remove(conn)
    del_list.clear()        
while True:
    try:
        conn,addr=phone.accept()   
        """
         接收客户端连接，如果有客户端连接，直接将连接对象加入到列表中等候处理。
         由于是非阻塞IO模型，如果此时没有客户端连接，将不会进程阻塞，但是会抛出一个异常BlockingIOError。
         当捕获到这个异常之后，就证明上一次没有客户端进行连接，此时就可以对已经接收的连接对象进程处理了。
        """
        conn_list.append(conn)
    except BlockingIOError:
        communtcaion(conn_list)        #对已经接收的连接对象进行处理。
        #
# 客户端
import socket
​
​
client = socket.socket()
client.connect(('127.0.0.1',8081))
​
​
while True:
    client.send(b'hello world')
    data = client.recv(1024)
    print(data)
```

**总结**

> **虽然非阻塞IO给你的感觉非常的牛逼**
> **但是该模型会  长时间占用着CPU并且不干活 让CPU不停的空转**
> **我们实际应用中也不会考虑使用非阻塞IO模型**
> **​**
> **任何的技术点都有它存在的意义 **
> **实际应用或者是思想借鉴**


# 4、IO多路复用

```shell
"""
当监管的对象只有一个的时候 其实IO多路复用连阻塞IO都比比不上！！！
但是IO多路复用可以一次性监管很多个对象
​
#server = socket.socket()
#conn,addr = server.accept()
​
监管机制是操作系统本身就有的 如果你想要用该监管机制(select)
需要你导入对应的select模块
"""
import  socket
import  select
server=socket.socket()
server.bind(("127.0.0.1",8080))
server.listen(5)
server.setblocking(False)
read_list=[server]
while True:
    total_num=512       #经过测试发现，此程序中select()能够监控的最多数量为512个socket对象，所以以下程序使用分批监测的策略，
                        #每次最多就检测512个对象
    num=len(read_list)//total_num
    if len(read_list)%total_num !=0:
       num+=1
    res_list=[]
    for i in range(num):     #分批，循环监测，然后将分批监测的结果保存在res_list[]列表中
        if i==num-1:
            tmp_list,*f=select.select(read_list[i*total_num:],[],[])
        else:
            tmp_list,*f=select.select(read_list[i*total_num:(i+1)*total_num],[],[])
        res_list.extend(tmp_list)
    """
    select.select()  
        -方法会监控你传入的，需要等待网络IO的对象，当select()方法监控到该对象接需要收到数据已经到达内存之后，
            就会返回一个元组。
        -元组的第一个元素就是一个列表，此列表中封装的就是需要对数据进行接收的对象。
        -select()  方法，一次性可监控多个对象，可以是相同类型的，也可以是不同类型的，比如有：
            1、socket.socket() 对象，是以一个TCP服务端。
            2、socket.socket().accept()[0] 对象，是一个TCP服务端的连接对象。
            3、select()能够监控的最大数量，顶多只有1024个，也就是说read_list列表中的数据，最多只能有1024个。
                    -但是经过实际测试，当前程序中，read_list中最大数量只能有512个，超过这个数量就会报错。
    参数：
        -第一个参数是一个列表，里面的元素，就是需要进行网络IO监控的对象
        -第二第三个参数，传入一个空列表即可。
    """
    for item in res_list:       #对已经接收到数据的对象进行处理
        if item is server:      #判断该对象类型，如果是TCP服务端
            conn,addr=item.accept()
            read_list.append(conn)
        else:                   #判断该对象类型是一个连接对象
            data=item.recv(1024)
            if len(data)==0:
                read_list.remove(item)
                continue
            print(data.decode("utf-8"))
            item.send(data.upper())
  # 客户端
from threading import  Thread
import  socket
import  time
def client():
    phone=socket.socket()
    phone.connect(("127.0.0.1",8080))
    try:
        phone.send("hello world".encode("utf-8"))
        data=phone.recv(1024)
        print(data.decode("utf-8"))
        time.sleep(2)
    except Exception:
        pass
    phone.close()
if __name__ == '__main__':
    old=time.time()
    task_list=[]
    for i in  range(2000):
        task=Thread(target=client)
        task_list.append(task)
        task.start()
    for item in task_list:
        item.join()
    print(time.time()-old)
#在Windows上，经过测试得知，一个任务耗时2秒的操作，在2000个任务的并发下，
#服务端使用IO多路复用select模型，仅需要6秒+即可完成所有的访问任务。
```

**总结**

> **监管机制其实有很多**
> **select机制  windows linux都有**
> **​**
> **poll机制    只在linux有   poll和select都可以监管多个对象 但是poll监管的数量更多**
> **​**
> **上述select和poll机制其实都不是很完美 当监管的对象特别多的时候**
> **可能会出现 极其大的延时响应**
> **​**
> **epoll机制   只在linux有**
> **    它给每一个监管对象都绑定一个回调机制**
> **    一旦有响应 回调机制立刻发起提醒**
> **​**
> **针对不同的操作系统还需要考虑不同检测机制 书写代码太多繁琐**
> **有一个人能够根据你跑的平台的不同自动帮你选择对应的监管机制**
> **selectors模块**


# 4、异步IO

```shell
"""
异步IO模型是所有模型中效率最高的 也是使用最广泛的
相关的模块和框架
    模块:asyncio模块
    异步框架:sanic tronado twisted
        速度快！！！
"""
import threading
import asyncio
​
​
@asyncio.coroutine
def hello():
    print('hello world %s'%threading.current_thread())
    yield from asyncio.sleep(1)  # 换成真正的IO操作
    print('hello world %s' % threading.current_thread())
​
​
loop = asyncio.get_event_loop()
tasks = [hello(),hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
```