**multiprocess.process模块**

# 1、process模块介绍

process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。[](javascript:void(0);)

```python
from multiprocessing import Process
p=Process(group, target, name, args , kwargs)     #由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）
强调：
    -需要使用关键字的方式来指定参数
    -args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号
参数介绍：
group参数未使用，值始终为None
target表示调用对象，即子进程要执行的任务
args表示调用对象的位置参数元组，args=(1,2,'jason',)
kwargs表示调用对象的字典,kwargs={'name':'jason','age':18}
name为子进程的名称
p.start()：启动进程，并调用该子进程中的p.run() 
p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  
p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，
    使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁
p.is_alive():如果p仍然运行，返回True
p.join([timeout]):主进程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。
    timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  
p.daemon：默认值为False，如果设为True，表示将p进程设置为守护进程，而主进程就是p进程需要守护的东西，如果主进程运行结束，那么p进程就没有
    可以守护的东西了，所以也会跟着结束。并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置
p.name:进程的名称
p.pid：进程的pid
p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)
p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。
    这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）
```

#  2、process创建进程

## 2.1 方法一：实例化对象创建进程

```
from multiprocessing import Process
import time
​​
def task(name):
    print('%s is running'%name)
    time.sleep(3)
    print('%s is over'%name)
​​
if __name__ == '__main__':
    # 1 创建一个对象
    p = Process(target=task, args=('jason',))
    # 容器类型哪怕里面只有1个元素 建议要用逗号隔开
    # 2 开启进程
    p.start()  # 告诉操作系统帮你创建一个进程  异步
    print('主')
    
```

[](javascript:void(0);)**注意：**

> **在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用****if __name__ ==‘__main__’**** 判断保护起来，import 的时候  ，就不会递归运行了。**


## 2.2 方法二 类的继承 创建进程

```
from multiprocessing import Process
import time
​
class MyProcess(Process):
    def run(self):
        print('hello bf girl')
        time.sleep(1)
        print('get out!')
​
if __name__ == '__main__':
    p = MyProcess()
    p.start()
    print('主')
```

**总结**

> **1、创建进程就是在内存中申请一块内存空间将需要运行的代码丢进去**
> **2、一个进程对应在内存中就是一块独立的内存空间**
> **3、多个进程对应在内存中就是多块独立的内存空间**
> **4、进程与进程之间数据默认情况下是无法直接交互,如果想交互可以借助于第三方工具、模块**


# 3、join方法

join是让主进程等待子进程代码运行结束之后，再继续运行。不影响其他子进程的执行

```python
from multiprocessing import Process
import time
​
def task(name, n):
    print('%s is running'%name)
    time.sleep(n)
    print('%s is over'%name)
​
if __name__ == '__main__':
    start_time = time.time()
    p_list = []
    for i in range(1, 4):
        p = Process(target=task, args=('子进程%s'%i, i))
        p.start()
        p_list.append(p)
    for p in p_list:
        p.join()
    print('主', time.time() - start_time)
```

# 4、进程之间数据相互隔离

```python
from multiprocessing import Process
money = 100​
def task():
    global money  # 局部修改全局
    money = 666
    print('子',money)
​
if __name__ == '__main__':
    p = Process(target=task)
    p.start()
    p.join()
    print(money)
```

# 5、进程对象及其他方法

```python
"""
一台计算机上面运行着很多进程，那么计算机是如何区分并管理这些进程服务端的呢？
计算机会给每一个运行的进程分配一个PID号 
如何查看
    windows电脑 
        进入cmd输入tasklist即可查看
        tasklist |findstr PID查看具体的进程
    mac电脑 
        进入终端之后输入ps aux
        ps aux|grep PID查看具体的进程 
"""
from multiprocessing import Process, current_process
current_process().pid  # 查看当前进程的进程号
current_process().name  #当前进程的名称
​
import os
os.getpid()  # 查看当前进程进程号
os.getppid()  # 查看当前进程的父进程进程号
os.name      #当前进程的名称
​
​
p.terminate()  # 杀死当前进程
# 是告诉操作系统帮你去杀死当前进程 但是需要一定的时间 而代码的运行速度极快
time.sleep(0.1)
print(p.is_alive())  # 判断当前进程是否存活
```

# 6、僵尸进程与孤儿进程(了解)

```python
# 僵尸进程
"""
死了但是没有死透
当你开设了子进程之后 该进程死后不会立刻释放占用的进程号
因为我要让父进程能够查看到它开设的子进程的一些基本信息 占用的pid号 运行时间。。。
所有的进程都会步入僵尸进程
    父进程不死并且在无限制的创建子进程并且子进程也不结束
    回收子进程占用的pid号
        父进程等待子进程运行结束
        父进程调用join方法
"""
​
# 孤儿进程
"""
子进程存活，父进程意外死亡
操作系统会开设一个“儿童福利院”专门管理孤儿进程回收相关资源
"""
```

# 7、守护进程

```python
from multiprocessing import Process
import time
​
​
def task(name):
    print('%s总管正在活着'% name)
    time.sleep(3)
    print('%s总管正在死亡' % name)
​
​
if __name__ == '__main__':
    p = Process(target=task,args=('egon',))
    # p = Process(target=task,kwargs={'name':'egon'})
    p.daemon = True  # 将进程p设置为守护进程，那么谁启动的p进程，就是p进程需要守护的那个进程，会与那个进程同生共死。
                        #这一句一定要放在start方法上面才有效否则会直接报错
    p.start()
    print('皇帝jason寿终正寝')
```