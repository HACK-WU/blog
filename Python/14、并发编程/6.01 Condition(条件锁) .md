Condition 是 python 中的条件锁，内部也是通过 Lock() 和 RLock() 锁实现，所以具有他们的阻塞特性， 并且在这基础上增加了暂停线程运行的功能，所以可以用来同步复杂的线程间通信。

条件锁的使用

```js
# 生成一个条件锁对象
cond = threading.Condition()
# 上锁
cond.acquire()
# 解锁
cond.release()
# 挂起线程，直到收到一个 notify 通知才会被唤醒
cond.wait()
# 唤醒一个 Condition 的 waiting 池中的线程
cond.notify()
# 唤醒所有 Condition 的 waiting 池中的线程
cond.notify_all()
```

我们来看一个例子，通过 cond 来歌曲对唱

```python
import threading
class Zhou(threading.Thread):
    def __init__(self, cond):
        super().__init__(name="周杰伦")
        self.cond = cond
                 
    def run(self):
        with self.cond:
            # Condition()对象中也实现了__enter__()与__exit__()魔法方法，所以也是可以通过 with 语句调用的
            print("{}: 海平面远方开始阴霾, 悲伤要怎么平静纯白".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 你用唇语说你要离开, 那难过无声慢了下来 ".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 转身离开, 你有话说不出来 ".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 我们的爱, 差异一直存在, 等待竟累积成伤害 ".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 蔚蓝的珊瑚海, 错过瞬间苍白 ".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 热情不再, 笑容勉强不来, 爱深埋珊瑚海".format(self.name))
        
                         
class Liang(threading.Thread):
    def __init__(self, cond):
        super().__init__(name="梁心颐")
        self.cond = cond
        
    def run(self):
        with self.cond:
            # 在调用with cond 之后才能调用 wait 或者 notify 方法
            self.cond.wait()
            print("{}: 我的脸上始终挟带, 一抹浅浅的无奈".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 汹涌潮水, 你听明白, 不是浪而是泪海 ".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 海鸟跟鱼相爱, 只是一场意外 ".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 转身离开, 分手说不出来 ".format(self.name))
            self.cond.notify()
            self.cond.wait()
            print("{}: 当初彼此, 不够成熟坦白".format(self.name))
            self.cond.notify()
                         
if __name__ == "__main__":
    cond = threading.Condition()
    liang = Liang(cond)
    zhou = Zhou(cond)
    # 这里的启动顺序很重要
    liang.start()
    zhou.start()
```

两个线程通过 cond 通信，阻塞自己并唤醒对方，从而达到有序执行，来看下打印结果

```js
周杰伦: 海平面远方开始阴霾, 悲伤要怎么平静纯白
梁心颐: 我的脸上始终挟带, 一抹浅浅的无奈
周杰伦: 你用唇语说你要离开, 那难过无声慢了下来 
梁心颐: 汹涌潮水, 你听明白, 不是浪而是泪海 
周杰伦: 转身离开, 你有话说不出来 
梁心颐: 海鸟跟鱼相爱, 只是一场意外 
周杰伦: 我们的爱, 差异一直存在, 等待竟累积成伤害 
梁心颐: 转身离开, 分手说不出来 
周杰伦: 蔚蓝的珊瑚海, 错过瞬间苍白 
梁心颐: 当初彼此, 不够成熟坦白
周杰伦: 热情不再, 笑容勉强不来, 爱深埋珊瑚海
```