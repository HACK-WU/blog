# 1、进程池与线程池(掌握)

```
"""
无论是开设进程也好还是开设线程也好 是不是都需要消耗资源
只不过开设线程的消耗比开设进程的稍微小一点而已
​
我们是不可能做到无限制的开设进程和线程的 因为计算机硬件的资源更不上！！！
硬件的开发速度远远赶不上软件呐
​
我们的宗旨应该是在保证计算机硬件能够正常工作的情况下最大限度的利用它
"""
# 池的概念
"""
什么是池?
    池是用来保证计算机硬件安全的情况下最大限度的利用计算机
    它降低了程序的运行效率但是保证了计算机硬件的安全 从而让你写的程序能够正常运行
"""
```

# 2、基本使用

## 2.1 线程池

```
from concurrent.futures import  ThreadPoolExecutor,ProcessPoolExecutor
from  threading import current_thread
import  os
import  time
def task(n,m):
    print(n,m,f"进程号：{os.getpid()}")
    time.sleep(2)
    return f"{current_thread().name } 运行完毕！！"
def callback(n):
    print(n.result())
if __name__ == '__main__':
    pool=ThreadPoolExecutor(5)      #实例化一个线程池,最大可装载5个线程，如果不设定，默认是CPU个数的5倍
    #res=pool.submit(task,2,3)       #提交task任务，第二个、第三个参数，是task()的参数,如果线程池，已经满了，就会被阻塞。
                                    #提交之后，会有一个返回结果，封装的这个线程的线程的对象以及运行状态。
    #res.result()               返回这个线程的运行的返回结果，如果线程没有运行完，会等待它的运行结果，也就是被阻塞.
    #pool.submit(task,2,3).add_done_callback(callback)      我们也可以在这个线程提交时，给它指定一个回调函数，
        #并将pool.submit()的返回结果res，作为参数传给这个回调函数，当线程运行完毕后，就会调用这个回调函数。
    #pool.shutdown()    关闭这个线程池，前提是所有的线程都执行完毕，否则会阻塞。
    for i in range(10):
        pool.submit(task,i,3).add_done_callback(callback)
```

## **2.2 进程池（用法和线程池一样）**

```
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
pool = ProcessPoolExecutor(5)
pool.submit(task, i).add_done_callback(call_back)
# 创建进程时，如果是windows 一定要写在main下面，
```

# 3、通过线程池实现TCP服务端并发效果

## 3.1 服务端

```
from concurrent.futures import  ThreadPoolExecutor,ProcessPoolExecutor
import  socket
pool=ThreadPoolExecutor(3)
phone=socket.socket()
phone.bind(("127.0.0.1",8080))
phone.listen(5)
def communcation(connection):
    conn=connection[0]
    while True:         #通讯循环
        try:
            data=conn.recv(1024)
            if len(data)==0:
                break
            print(data.decode("utf-8"))
            conn.send(data.upper())
        except ConnectionResetError as e:
            print(e)
            break
while True:             #链接循环
    connection=phone.accept()          
    pool.submit(communcation,connection)
phone.closed()
pool.shutdown()
```

## 3.2 客户端

```
import  socket
import  time
phone=socket.socket()
phone.connect(("127.0.0.1",8080))
while True:
    phone.send("hello world".encode("utf-8"))
    data=phone.recv(1024)
    print(data.decode("utf-8"))
    time.sleep(2)
phone.closed()
```