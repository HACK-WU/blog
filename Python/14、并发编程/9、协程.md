# 1、协程

```shell
"""
进程:资源单位
线程:执行单位
协程:这个概念完全是程序员自己意淫出来的 根本不存在
        单线程下实现并发
        我们程序员自己再代码层面上检测我们所有的IO操作
        一旦遇到IO了 我们在代码级别完成切换
        这样给CPU的感觉是你这个程序一直在运行 没有IO
        从而提升程序的运行效率
    
多道技术
    切换+保存状态
    CPU两种切换
        1.程序遇到IO
        2.程序长时间占用
​
TCP服务端 
    accept
    recv
    
代码如何做到
    切换+保存状态
​
切换
    切换不一定是提升效率 也有可能是降低效率
    IO切         提升
    没有IO切 降低
        
保存状态
    保存上一次我执行的状态 下一次来接着上一次的操作继续往后执行
    yield
"""
```

# 2、验证切换是否就一定提升效率

```shell
# import time
#
# # 串行执行计算密集型的任务   1.2372429370880127
# def func1():
#     for i in range(10000000):
#         i + 1
#
# def func2():
#     for i in range(10000000):
#         i + 1
#
# start_time = time.time()
# func1()
# func2()
# print(time.time() - start_time)
​
​
​
​
​
# 切换 + yield  2.1247239112854004
# import time
#
# def func1():
#     while True:
#         10000000 + 1
#         yield
#
#
# def func2():
#     g = func1()  # 先初始化出生成器
#     for i in range(10000000):
#         i + 1
#         next(g)
#
# start_time = time.time()
# func2()
# print(time.time() - start_time)
```

# 3、gevent模块(了解)

## 3. 1 安装

```shell
pip3 install gevent
```

```shell
from gevent import monkey;monkey.patch_all()
import time
from gevent import spawn
​
"""
gevent模块本身无法检测常见的一些io操作
所以在使用的时候需要你额外的导入一句话
from gevent import monkey
monkey.patch_all()
又由于上面的两句话在使用gevent模块的时候是肯定要导入的
所以还支持简写
from gevent import monkey;monkey.patch_all()
"""
​
​
def heng():
    print('哼')      
    time.sleep(2)
    print('哼')
​
​
def ha():
    print('哈')
    time.sleep(3)
    print('哈')
​
def heiheihei():
    print('heiheihei')
    time.sleep(5)
    print('heiheihei')
​
​
start_time = time.time()
g1 = spawn(heng)  #spawn() 可以用于检测有IO操作的线程。
g2 = spawn(ha)    #异步提交, 并监测
g3 = spawn(heiheihei)
g1.join()
g2.join()  # 等待被检测的任务执行完毕 再往后继续执行
g3.join()
# heng()
# ha()
# print(time.time() - start_time)  # 5.005702018737793
print(time.time() - start_time)  # 3.004199981689453   5.005439043045044
```

> **程序分析：	**
> **1、首先以上程序只有一个线程，而一个线程的执行一定是串行执行。			**
> **-如果没有使用到协程操作：				**
> **  heng()				**
> **  he()				**
> **  heiheihei()				**
> **-那么这段程序的执行时间，应该是10秒+	**
> **2、但是如果使用协程技术，		**
> **   -当运行heng()时，遇到了IO操作（阻塞），会立即切换到he()中，进行执行		**
> **      在he()函数执行时，如果又遇到IO操作，又会再次切换。	     **
> **  -用这样的方式，让CPU始终处于计算服务中，而不用按照原来的计划，需要先等等IO操作完毕，之后在计算服务。           **
> **    大大的节省了时间。		**
> **  -这样的话，相当于在一个线程中并发执行IO操作，然后让所有的计算服务全部集中运算。			**
> **    以此节省了时间。	   **
> **   -如果不这样，那么该线程中的计算，都必须是先等待IO，再进行计算服务，这也太慢了吧。			**


# 4、协程实现TCP服务端的并发

```shell
# 服务端
from gevent import monkey;monkey.patch_all()
from gevent import spawn
import time
import socket
phone=socket.socket()
phone.bind(("127.0.0.1",8080))
phone.listen(5)
def communtcaion(connection):
    conn=connection[0]
    while True:             #通讯循环
        try:
            data=conn.recv(1024)
            if len(data)==0:
                break
            print(data.decode("utf-8"))
            conn.send(data.upper())
        except ConnectionResetError as e :
            print(e)
            break
    conn.close()
while True:             #连接循环
    connection=phone.accept()
    task=spawn(communtcaion,connection)
    
# 客户端
from threading import Thread, current_thread
import socket
​
​
def x_client():
    client = socket.socket()
    client.connect(('127.0.0.1',8080))
    n = 0
    while True:
        msg = '%s say hello %s'%(current_thread().name,n)
        n += 1
        client.send(msg.encode('utf-8'))
        data = client.recv(1024)
        print(data.decode('utf-8'))
​
​
if __name__ == '__main__':
    for i in range(500):
        t = Thread(target=x_client)
        t.start()
```

**总结**

```shell
"""
理想状态:
    我们可以通过
    多进程下面开设多线程
    多线程下面再开设协程序
    从而使我们的程序执行效率提升
"""
```