**分代回收**

# 3.1引入目的

- 问题：

- 什么时候扫描去检测循环引用？

- 标记和清除的过程效率不高。清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分

活动对象也要扫描所有对象。

为了解决上述的问题，python又引入了分代回收。

# 3.2原理

将第二个链表（可能存在循环引用的链表），维护成3个环状双向的链表：

- 0代： 0代中对象个数达到700个，扫描一次。

- 1代： 0代扫描10次，则1代扫描1次。

- 2代： 1代扫描10次，则2代扫描1次。

![](images/WEBRESOURCEdfd2f1a72ecd31e8ba4b218bf382f980截图.png)

```
// 分代的C源码
#define NUM_GENERATIONS 3
struct gc_generation generations[NUM_GENERATIONS] = {
 /* PyGC_Head,                  threshold,  count */
 {{(uintptr_t)_GEN_HEAD(0), (uintptr_t)_GEN_HEAD(0)},  700,    0}, //
0代
 {{(uintptr_t)_GEN_HEAD(1), (uintptr_t)_GEN_HEAD(1)},  10,     0}, //
1代
 {{(uintptr_t)_GEN_HEAD(2), (uintptr_t)_GEN_HEAD(2)},  10,     0}, //
2代
};
```

例：

![](images/WEBRESOURCE628c4934f0151b3025acecfa1273ec2d截图.png)

当我们创建一

当我们创建一个对象 = [11,22],除了加到refchain，那么它会加到0代链表中去。

如果再创建一个对象v2 = [33,44],那么它还是往0代添加。

直到0代中的个数达到700之后，就会对0代中的所有元素进行一次扫描，扫描时如果检测出是循环引用

那么引用计数器就自动-1，然后判断引用计数器是否为0，如果为0，则为垃圾就进行回收。不是垃圾的

话，就对该数据进行升级，从0代升级到1代，这个时候0代就是空，1代就会记录一下0代已经扫描1次，

然后再往0代中添加对象直到700再进行一次扫描，不停反复，直到0代扫描了10次，才会对1代进行1次

扫描。

分代回收解决了标记清楚时什么时候扫描的问题，并且将扫描的对象分成了3级，以及降低扫描的工作

量，提高效率。

# 3.3弱代假说

为什么要按一定要求进行分代扫描？

这种算法的根源来自于弱代假说(weak generational hypothesis)。

这个假说由两个观点构成：首先是年轻的对象通常死得也快，而老对象则很有可能存活更长的时间。

假定现在我用Python创建一个新对象 n1="ABC"

根据假说，我的代码很可能仅仅会使用ABC很短的时间。这个对象也许仅仅只是一个方法中的中间结

果，并且随着方法的返回这个对象就将变成垃圾了。大部分的新对象都是如此般地很快变成垃圾。然

而，偶尔程序会创建一些很重要的，存活时间比较长的对象，例如web应用中的session变量或是配置项。

频繁的处理零代链表中的新对象，可以将让Python的垃圾收集器把时间花在更有意义的地方：它处理那

些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足一定的条件，收集器才回去处理那些老变量。