**缓存机制**

缓存在python中分为两大类

# 5.1池

在python中为了避免重复创建和销毁一些常见对象，维护池。

例：

```
v1 = 7
v2 = 9
v3 = 9
# 按理说在python中会创建3个对象，都加入refchain中。
```

然而python在启动解释器时，python认为-5、-4、….. 、256，bool、一定规则的字符串，这些值都是

常用的值，所以就会在内存中帮你先把这些值先创建好，接下来进行验证：

```
# 启动解释器时，python内部帮我们创建-5、-4、...255、256的整数和一定规则的字符串
v1 = 9 # 内部不会开辟内存，直接去池中获取
v2 = 9 # 同上，都是去数据池里直接拿9，所以v1和v2指向的内存地址是一样的
print(id(v1),id(v2))
v3 = 256 # 内部不会开辟内存，直接去池中获取
v4 = 256 # 同上，都是去数据池里直接拿256，所以v3和v4指向的内存地址是一样的
print(id(v3),id(4))
v5 = 257
v6 = 257
print(id(v5),id(v6))
```

排查原因：版本不同，小数据池扩大。

在交互模式下返回得结果符合预期，文件模式的情况下

问题：为什么交互模式和命令模式结果有区别？

答：因为代码块的缓存机制。

- 什么是代码块？

一个模块、一个函数、一个类、一个文件等都是一个代码块；交互式命令下，一行就是一个代码块。

- 同一个代码块内的缓存机制（字符串驻留机制）

- 机制内容：Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存

在，如果存在，会将其重用，即将两个变量指向同一个对象。换句话说：执行同一个代码块

时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的

变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这

个值。所以在用命令模式执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足

缓存机制则他们在内存中只存在一个，即：id相同。

- 适用对象： int（float），str，bool。

- 对象的具体细则：（了解）

- int(float)：任何数字在同一代码块下都会复用。

- bool：True和False在字典中会以1，0方式存在，并且复用。

- str：几乎所有的字符串都会符合字符串驻留机制

```
# 同一个代码块内的缓存机制————任何数字在同一代码块下都会复用
i1 = 1000
i2 = 1000
print(id(i1))
print(id(i2))
输出结果：
# 同一个代码块内的缓存机制————几乎所有的字符串都会符合缓存机制
s1 = 'hfdjka6757fdslslgaj@!#fkdjlsafjdskl;fjds中国'
s2 = 'hfdjka6757fdslslgaj@!#fkdjlsafjdskl;fjds中国'
print(id(s1))
print(id(s2))
输出结果：
# 同一个代码块内的缓存机制————非数字、str、bool类型数据，指向的内存地址一定不同
t1 = (1,2,3)
t2 = (1,2,3)
l1 = [1,2,3]
l2 = [1,2,3]
print(id(t1))
print(id(t2))
print(id(l1))
print(id(l2))
输出结果：
```

- 不同代码块间的缓存机制（小数据池、小整数缓存机制、小整数驻留机制）

- 适用对象： int（float），str，bool

- 具体细则：-5~256数字，bool，满足一定规则的字符串。

- 优点：提升性能，节省内存。

- Python自动将-5~256的整数进行了缓存，当你将这些整数赋值给变量时，并不会重新创建对

象，而是使用已经创建好的缓存对象。

- python会将一定规则的字符串在字符串驻留池中，创建一份，当你将这些字符串赋值给变量	

时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。

- 其实，无论是缓存还是字符串驻留池，都是python做的一个优化，就是将~5-256的整数，和

一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中那些变量指向这些范围

内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存中之创建一个。

```
# 创建文件1: file1
def A():
 b = 1
 print(id(b))
# 创建文件2: file2
from file1 import A
a = 1
print(id(a))
A()
```

总结一下就是，同一个代码块中(交互模式中的)因为字符串驻留机制，int（float），str，bool这些数据

类型，只要对象相同，那么内存地址共享。

而不同代码块中只有引用对象为-5~256整数，bool，满足一定规则的字符串，才会有内存共享，即id相同。

并且这些python编辑器初始化的数据，他们的引用计数器永远不会为0,在初始化的时候就会将引用计数

器默认设置为1。

# 5.2 free_list

当一个对象的引用计数器为0的时候，按理说应该回收，但是在python内部为了优化，不会去回收，而

是将对象添加到free_list链表中当作缓存。以后再去创建对象时就不再重新开辟内存，而是直接使用free_list。

```
v1 = 3.14 # 创建float型对象，加入refchain，并且引用计数器的值为1
del v1  #refchain中移除，按理说应该销毁，但是python会将对象添加到free_list中。
v2 = 9.999 # 就不会重新开辟内存，去free_list中获取对象，对象内部数据初始化，再放到
refchain中。
```

但是free_list也是有容量的，不是无限收纳, 假设默认数量为80，只有当free_list满的时候，才会直接去销毁。

代表性的有float/list/tuple/dict，这些数据类型都是以free_list方式来进行回收的。

缓存列表对象的创建源码：

总结一下，就是引用计数器为0的时候，有的是直接销毁，而有些需要先加入缓存当中的。

每个数据类型的缓存链表源码详见：

[[https://pythonav.com/wiki/detail/6/88/#2.4%20int%E7%B1%BB%E5%9E%8B](https://pythonav.com/wiki/detail/6/88/#2.4%20int%E7%B1%BB%E5%9E%8B)]

([https://pythonav.com/wiki/detail/6/88/#2.4](https://pythonav.com/wiki/detail/6/88/#2.4)

# C源码分析

arena 是 CPython 的内存管理结构之一。代码在 Python/pyarena.c 中其中包含了 C 的内存分配和解

除分配的方法。

[https://github.com/python/cpython/blob/master/Python/pyarena.c](https://github.com/python/cpython/blob/master/Python/pyarena.c)

Modules/gcmodule.c ，该文件包含垃圾收集器算法的实现。

[https://github.com/python/cpython/blo](https://github.com/python/cpython/blo)

b/master/Modules/gcmodule.c