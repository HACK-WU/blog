**cookie与session**

# 1、利用cookie实现用户登录状态保存

## urls：

```python
#登录功能
re_path(r"^login",views.login),
re_path(r"^home",views.home),
re_path(r"^index",views.indx),
re_path(r"^func",views.func),
#注销功能
re_path(r"^loginout",views.loginout)
```

## 视图函数

```python
from django.shortcuts import render,HttpResponse,redirect
# Create your views here.
1、校验用户是否登录的装饰器
#1、校验前，先获取当前用户一开始想要访问的url:
#        target=request.path_info          :用户访问的路径，比如/login/
#        target=request.get_full_path()    ：用户访问的全路径，比如：/login?name=1
#2、然后然后获取cookie中对应的键值：
#        request.COOKIES.get("name") :判断，如果不为空，证明已经登录
#3、如果已经登录，直接返回返回原函数的对象，否则默认返回登录页面，并将原来的url,通过get方式，传递过去
#        return redirect(f"/login?next={target}") 
#最后返回内部函数inner(request,*args,**kwagrs)
#        return inner  
             
def login_auth(func):                     
    def inner(request,*args,**kwargs):
        target=request.get_full_path()
        if request.COOKIES.get("username"):
            return func(request,*args,**kwargs)
        else:
            return redirect(f"/login?next={target}")        
    return inner
2、登录函数
#1、当访问方式为POST是，获取用户名和密码，然后校验用户名和密码是否在正确。
#    -注意只要调用了这个函数，就证明没有登录，校验成功后，需要设置对应的cookie，以免短时间内再次登录，obj.set_cookie()
#2、如果校验成功，需要知道用户本来想访问哪个网页target，然后重定向到到对应的页面。如果target为空，证明用户只是想登录，然后默认重定向到首页：
#    target=request.GET.get("targer")    :获取之前的想要访问的路基
#    obj=redirect(targer)    #obj，是响应对象
#3、通过响应对象，将用户的状态信息，添加到cookie中，也就是添加cookie前，需要前确定需要返回的响应对象：
#    obj.set_cookie("login_static","yes",max_age=30,expires=30)
#4、最后返回响应对象:
#    return obj   
 
 
def login(request):
    if request.method=="POST":
        userame=request.POST.get("username")
        pwd=request.POST.get("pwd")
        if userame=="hack" and pwd=="123":
            #获取用户上一次想要访问的URL
            target=request.GET.get("next")      #这个结果可能是none，第一次请求时使用get方法，那时候就存储了next的键值
            if target:
                obj=redirect(target)
            else:
                #保存用户状态
                obj=redirect("/home/")
            #让浏览器纪录数据
            obj.set_cookie("username","666",max_age=3,expires=3)
            #超时时间3秒
            #跳转到一个用户登录之后才能访问的页面
            return  obj
    return render(request,"login.html")
3、退出函数
#1、退出页面，也需要在登录状态下执行
#2、获取响应对象后,删除cookie的键值：
#    obj=redirect("/index/")
#    obj.delete_cookie("login_static")
@login_auth
def loginout(request):            #删除cookie的某个键值对
    obj=redirect("/login/")
    obj.delete_cookie("username")
    return obj
4、其他页面的视图函数
#1、通过自动登录校验之后，就可正常访问指定的页面
@login_auth
def home(request):
    return HttpResponse("home页面")
@login_auth
def indx(request):
    return HttpResponse("index页面")
@login_auth
def func(request):
    return HttpResponse("func页面")
```

# 2、内容回顾


## cookie与session

```
# 由于http协议是无状态的

# cookie概念
	服务端设置保存在客户端浏览器上的键值对(只要符合前面的定义都可以叫cookie)
	cookie虽然是服务端设置的但是浏览器可以选择不保存
  
# session概念
	存储在服务端上的键值对(用来标识当前用户)				需要基于cookie才能工作
  其实大部分的保存状态的实现都需要基于cookie来做

# 在web领域没有绝对的安全
	基本上防御措施都需要程序员自己写代码完善，并且之内完善没法杜绝

```

## django操作cookie

```python
```

## django操作session

```
   """
1.session是存储在服务端的 django默认情况下是需要借助于django_session表来存储数据 也就意味着如果你想要操作session那么必须先执行数据库迁移命令让django先把django_session表创建出来(no such table:django_session)

2.django默认的session过期时间是14天

3.session存储在服务端 可以有很多地方存储
	1.表
	2.文件
	3.缓存
	4.其他
	...
"""
# 设置
request.session[key] = value
	"""
	三件事
	"""
# 获取
request.session.get(key)
	"""
	三件事
	"""
# 删除
request.session.delete()
request.session.flush()
# 设置超时时间
request.session.set_expiry()

  1.数字															秒数
  2.datetime/timedelta格式						日期格式
  3.None														 参加全局失效策略
  4.0																 窗口关闭即失效

"""
基于session实现用户登陆

有时候如果多个视图函数都需要使用到一些数据的话，你也可以考虑将该数据存储到django_session表中，方便后续的使用
	eg:
		登陆验证码(bbs作业会涉及到)
"""

```

## CBV如何添加装饰器

```python
```