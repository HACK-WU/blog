**csrf 跨站请求伪造**

**获取csrf_token的js文件：myset.js**

```javascript
function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
var csrftoken = getCookie('csrftoken');
function csrfSafeMethod(method) {
    // these HTTP methods do not require CSRF protection
    return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
}
$.ajaxSetup({
    beforeSend: function (xhr, settings) {
        if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
            xhr.setRequestHeader("X-CSRFToken", csrftoken);
        }
    }
});
```

# **1、csrf跨站请求**

```javascript
"""
钓鱼网站
本质: 
    用假网站代替真网站，获取用户数据朝真网站提交，中途修改一些参数	
        eg:网页银行转账的例子 
解决办法: 在给用户返回的具有可以提交post请求的页面上添加一个唯一标记 
        之后该页面发送post请求到后端，会先校验该唯一标记
"""
form表单如何获取
 在form表单内书写{% csrf_token %}
  <input type='hidden' name='csrfmiddlewaretoken' value='唯一的随机字符串'/>
ajax如何如何
 1.自己利用标签查找获取值
 data:{'csrfmiddlewaretoken':'$("[name=csrfmiddlewaretoken]").val()'}
  2.利用模版语法
 data:{'csrfmiddlewaretoken':'{{ csrf_token }}'}
  3.通用的 js文件
 拷贝固定的js代码导入到你的html页面上即可
```

# **2、csrf相关装饰器**

```javascript
"""
from django.views.decorators.csrf import csrf_protect,csrf_exempt
csrf_protect:需要校验csrf
 跟我们之前学习的三种给CBV加装饰器的玩法一样
csrf_exempt:忽略校验csrf
 只能作用于dispatch方法
他们两个在FBV上使用方式一致，就是普通的装饰器玩法
而在CBV上两者却有区别
"""
```