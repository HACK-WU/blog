```python
from django.db import models

    
from django.contrib.auth.models import AbstractUser
class BaseModel(models.Model):	
    is_delete=models.BooleanField(default=False)	#这里虽然写的BOOL但是存到数据的时候，就是0和1
    # auto_now_add=True 只要记录创建，不需要手动插入时间，自动把当前时间插入
    create_time=models.DateTimeField(auto_now_add=True)
    # auto_now=True,只要更新，就会把当前时间插入
    last_update_time=models.DateTimeField(auto_now=True)
    # import datetime
    # create_time=models.DateTimeField(default=datetime.datetime.now)
    class Meta:
        # 单个字段，有索引，有唯一
        # 多个字段，有联合索引，联合唯一
        abstract=True  # 抽象表，不再数据库建立出表




class Book(BaseModel):
    id=models.AutoField(primary_key=True)
    # verbose_name admin中显示中文
    name=models.CharField(max_length=32,verbose_name='书名',help_text='这里填书名')
    price=models.DecimalField(max_digits=5,decimal_places=2)
    # 一对多的关系一旦确立，关联字段写在多的一方
    #to_field 默认不写，关联到Publish主键
    #db_constraint=False  逻辑上的关联，实质上没有外键练习，增删不会受外键影响，但是orm查询不影响
    publish=models.ForeignKey(to='Publish',on_delete=models.DO_NOTHING,db_constraint=False)

    # 多对多，跟作者，关联字段写在 查询次数多的一方

    # 什么时候用自动，什么时候用手动？第三张表只有关联字段，用自动    第三张表有扩展字段，需要手动写
    # 不能写on_delete
    authors=models.ManyToManyField(to='Author',db_constraint=False)
    class Meta:
        verbose_name_plural='书表'  # admin中表名的显示
```