# 第十二章 动态规划讲解

动态规划（

20

动态规划的应用极其广泛，包括

## 12.1 动态规划概念和思想

动态规划过程是：把原问题划分成多个“阶段”，依次来做“决策”，得到当前的局部解；每次决策，会依赖于当前“状态”，而且会随即引起状态的转移。

这样，一个决策序列就是在变化的状态中，“动态”产生出来的，这种多阶段的、最优化决策，解决问题的过程就称为

### 12.1.1 基本思想

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一个子问题的解，会为后一子问题的求解，提供有用的信息。

在求解一个子问题的时候，我们会列出、所有可能的局部解，通过“决策”，保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决每个子问题，最后一个子问题，也就是最后一个阶段的问题，那就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的。

动态规划通常用来求解

这类问题可以有很多可行解，每个解都对应一个值，我们希望找到具有最优值（最大或最小）的解。

### 12.1.2 基本步骤

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策就形成了一个决策序列，同时也就确定了，完成整个过程的一条活动路线。

初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态

动态规划的设计都有着一定的模式，一般要经历以下几个步骤。

（

（

（

因为决策和状态转移有着天然的联系，状态转移就是：根据上一阶段的状态和决策，来导出本阶段的状态。

（

给出的状态转移方程一般是一个递推式，需要一个递推的终止条件或边界条件。

 

实际应用中可以按以下几个简化的步骤进行设计：

（

（

（

（

在具体应用中，最优二叉搜索树、最长公共子序列、背包问题等等都是动态规划的典型应用场景，其它一些不容易直接看出思路的题目，也往往可以用动态规划来解决。所以可以说是面试中的“杀手锏，也是一个考察重点。

## 12.2 从斐波那契数列说起

斐波那契数列（

1, 1, 2, 3, 5, 8, 13, 21, 34, …

它的规律是：当前数字，是之前两个数字之和。

在数学上，斐波那契数列以如下被以递推的方法定义：

F(0)=0

### 12.2.1 递归实现

如果用代码来实现，显然用递归是顺利成章的事情：

**public class **

### 12.2.2 复杂度分析

可以看出，这样递归实现代码非常简洁易懂，但其实算法复杂度很高，非常低效。

这里我们假设

![](images/WEBRESOURCE35416e2edf039c42c17a01e207ba6ffclocalFile)

这是一棵二叉树，可以把原问题分成两个子问题。

也就是说，想要计算原问题

我们发现，递归树中每个节点都代表了一次加法计算。所以当前递归子问题的个数，其实就是整个递归树节点的个数。根据二叉树的知识，节点个数为

综上，算法的时间复杂度为

考虑到递归栈的调用，空间复杂度为

### 12.2.3 动态规划实现

观察递归树，很明显可以发现算法低效的原因：存在大量重复计算。这就是可以应用动态规划问题的重要性质：具有

我们可以做一个“备忘录”，每次算出某个子问题的答案就记到“备忘录”里；而每次遇到一个子问题时，先去“备忘录”里查找，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。一般可以使用一个数组充当这个“备忘录”，当然也可以使用哈希表。

所以我们选取从

状态转移方程，就是：

![](images/WEBRESOURCE1e63eaf8362c487bcc5b2b44041e5b33localFile)

当计算到

代码如下：

*// *

显然，这个过程中，我们只用到了一个循环遍历，时间复杂度为

空间复杂度为

通过这个例子我们可以看出，所谓动态规划，其实就是对复杂问题进行划分、并对重复子问题进行一遍求解和保存、最终得到最优解的过程。

### 12.2.4 空间优化

我们可以发现，这里其实不需要保存数组。因为状态转移方程中，当前状态只跟之前的两个值有关，所以保存两个值就够了。

代码如下：

*//*

**复杂度分析**

时间复杂度：

空间复杂度：

## 12.3  0-1背包问题

【

物品：

重量：

价值：

一般化表达：

一共有

### 12.3.1 问题分析

和之前提到过的背包问题不同，现在少了“物品可以分割成任意大小”这个条件。这个条件是我们使用贪心策略的关键，所以现在不能像之前那样简单处理了。我们的解决策略就是——动态规划。

（

首先我们考虑最终解的形式，每个物品只有选取、不选取两种情况，总共有

现在我们试图将最终的解进行分解，转化成多个阶段。我们知道，当前问题具有最优子结构，也就是说，得到最优解之后，如果从中减去一个物品

所以我们的目标是背包内物品的总价值，而变量是物品和背包的限重，可定义状态

dp[i][j]

0<=i<=N, 0<=j<=W

（

我们可以将

l

l

即状态转移方程为：

dp[i][j] = max(dp[i−1][j],dp[i−1][j−w[i]]+v[i])     // j >= w[i]

（

我们可以遍历

dp[i-1][j] 

和

dp[i-1][j-w[i]] + v[i] 

比较取最大值。它们中的最大值，可以保证，这就是

（

最终我们要得到

### 12.3.2 代码实现

**public class **

dp[i-

**复杂度分析**

时间复杂度：

空间复杂度：

### 12.3.3 空间优化

我们发现，使用二维数组保存状态，空间复杂度较高。

由状态转移方程可知，

所以我们可以考虑去掉

代码如下：

*// *

**复杂度分析**

时间复杂度：

空间复杂度：

## 12.4 买卖股票的最佳时机（#121）

### 12.4.1 题目说明

给定一个数组，它的第

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

示例

输入

输出

解释

注意利润不能是

示例

输入

输出

解释

### 12.4.2 分析

最简单的想法是，直接找到最大最小值。但最小值可能在最大值之后出现，不符合题目要求。

所以我们应该先确定买入点（低点），再考虑之后的卖出点（高点）。

### 12.4.3 方法一：暴力法

首先可以想到暴力解法：直接遍历每一个价格，作为买入点；再遍历它之后的每一个价格，作为卖出点，取差价最大值即可。

代码如下：

**public class **

**复杂度分析**

时间复杂度：

空间复杂度：

### 12.4.4 方法二：动态规划

我们发现，只要在卖出时才能真正确定利润；而要想获取最大利润，就一定要在之前的“历史最低点”买入。

所以我们可以以每一天为阶段，确定到目前为止的最优策略，并不断更新。很明显，这就是动态规划的思路。

具体策略是：遍历数组，以当天价格卖出，如果大于之前的最大利润，则更新；而最优的买入点，应该是到目前为止的历史最低价格。每天的价格可能会影响到目前为止的历史最低价格。

所以我们其实只需要保存历史最低价格以及目前可能的最大利润。

代码如下：

**public int **

**复杂度分析**

时间复杂度：

空间复杂度：

## 12.5 爬楼梯（#70）

### 12.5.1 题目说明

假设你正在爬楼梯。需要

每次你可以爬

注意：给定

示例

输入：

输出：

解释：

1.  1 

2.  2 

示例

输入：

输出：

解释：

1.  1 

2.  1 

3.  2 

### 12.5.2 分析

这是一道非常经典的面试题。爬楼梯需要一步一步爬，很明显，这可以划分阶段、用动态规划的方法来解决。

对于爬

所以我们可以将到达

于是有状态转移方程：

![](images/WEBRESOURCEe398ce4d123ad77cbe0c87f069831a1flocalFile)

### 12.5.3 方法一：动态规划

代码如下：

**public class **

**复杂度分析**

时间复杂度：

空间复杂度：

上述解法中，我们发现

代码如下：

*// 动态规划空间优化*

**复杂度分析**

时间复杂度：

空间复杂度：

### 12.5.4 方法二：数学方法

我们发现，状态转移方程

![](images/WEBRESOURCEc831e2cb9153b0ecbc3e3e3c339f77delocalFile)

其实就是斐波那契数列的递推公式，所以这道题目的求解，其实就是要求斐波那契数列的某一项。

通过数学方法，可以推出斐波那契数列的通项公式为：

![](images/WEBRESOURCEe09e79111492ac33070201c760d6957flocalFile)

所以，我们可以通过公式直接得到结果。

这里需要注意的是，爬楼梯的数列其实是：

对比真正的斐波那契数列，少了第一项

代码如下：

*// 方法二：数学法*

**复杂度分析**

时间复杂度：

空间复杂度：

## 12.6 最长公共子序列（#1143）

### 12.6.1 题目说明

给定两个字符串

一个字符串的

例如，

若这两个字符串没有公共子序列，则返回

示例

输入：

输出：

解释：最长公共子序列是

示例

输入：

输出：

解释：最长公共子序列是

示例

输入：

输出：

解释：两个字符串没有公共子序列，返回

提示

l

text1.length <= 1000

l

text2.length <= 1000

l

### 12.6.2 分析

这也是一道动态规划的经典题目，很多较难的字符串问题都可以用类似的解法解决。

在生物学应用中，经常会用到比较两个

抽象之后，这就变成了字符串最长公共子序列的问题。

我们发现，这个问题是有最优子结构的。

我们假设得到了字符串

l

l

如果我们按照字符串长度来划分阶段，很明显不同阶段中的子序列，是会重复遍历的。

所以，这是一个典型的具有最优子结构、而且子问题有重叠的问题，可以用动态规划来解决。

### 12.6.3 动态规划实现

（

分别考虑字符串

为了将子问题的解保存下来，我们定义一个二维矩阵

![](images/WEBRESOURCE9842818cb7016defb80417ec7491e1c1localFile)

这里

例如上图中，

（

如果已经得到了上一阶段的最长子序列，那么接下来就是要扩充

l

那么没有它们时，

dp[i, j] = dp[i-1, j-1] + 1

l

那么只追加一个

dp[i, j] = max(dp[i-1, j], dp[i, j-1] )

![](images/WEBRESOURCEa59ef5885279f9aa6d83881b0db49864localFile)

（

最终我们可以得到

代码如下：

**public class **

复杂度分析

时间复杂度：

空间复杂度：

## 12.7 打家劫舍（#198）

### 12.7.1 题目说明

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下

示例

输入：

输出：

解释：

偷窃

偷窃到的最高金额

示例

输入：

输出：

解释：

偷窃

偷窃到的最高金额

**提示：**

l

l

### 12.7.2 分析

由于不能偷窃连续的房屋，我们自然想到，隔一个偷一间显然是一个不错的选择。那是不是，直接计算所有奇数项的和，以及所有偶数项的和，取最大值就可以了呢？并没有这么简单。

例如，如果是

这里的关键是，对于三个连续的房屋

所以我们发现，从最后往前倒推，最后一间屋

l

l

所以，这明显是一个动态规划的问题。

### 12.7.3 动态规划实现

我们可以将前

可以得到状态转移方程：

![](images/WEBRESOURCE9d0df1b41e9deaa5d95f2dca3c1bb4c5localFile)

代码如下：

**public class **

*        *

**复杂度分析**

时间复杂度：

空间复杂度：

### 12.7.4 空间优化

上述方法使用了数组存储结果。

我们通过状态方程可以发现，每间房屋的最高总金额，只和该房屋的前两间房屋的最高总金额相关。因此只要存储之前两间房屋的最高金额就可以了。

代码如下：

*// 动态规划空间优化*

**复杂度分析**

时间复杂度：

空间复杂度：

## 12.8 零钱兑换（#322）

### 12.8.1 题目说明

给定不同面额的硬币

你可以认为每种硬币的数量是无限的。

示例

输入：

输出：

解释：

示例

输入：

输出：

示例

输入：

输出：

示例

输入：

输出：

示例

输入：

输出：

提示：

l

l

l

### 12.8.2 分析

这道题要求硬币总面值加起来等于

最简单的想法，就是直接暴力列出所有可能的情况。我们可以依次考虑每种硬币，先计算出每种硬币可能的最大个数，然后遍历每种可能，选择其中面值和为

由于每种硬币可能的最大个数和

暴力法的时间复杂度为指数级，这在一般场景下是不可接受的。

为了改进算法性能，我们可以考察凑出

每一步增加一个硬币，硬币个数加

所以我们可以看出来，这就是一个典型的动态规划问题。

![](images/WEBRESOURCE0126bbee80b85dd73f4060b7b95956celocalFile)

### 12.8.3 动态规划实现

我们定义一个状态数组

那么状态转移方程就是：

![](images/WEBRESOURCEa24ceb660338a9ec280a22d4dd9fdbeelocalFile)

代码如下：

*// 动态规划*

**复杂度分析**

时间复杂度：

空间复杂度：