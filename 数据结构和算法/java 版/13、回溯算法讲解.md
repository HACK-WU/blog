# 第十三章 回溯算法讲解

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”

## 13.1 回溯的概念和思想

### 13.1.1 基本概念

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

### 13.1.2 基本思想

回溯法的基本思想，其实就是不停地搜索寻找，而且是定了一个方向，就会不停向下深入，遇到岔路，就选一个一直走下去，直至此路不通，就返回再找另一条可能的岔路。

这其实就是所谓的“深度优先搜索”。深度优先搜索（

一个最优化问题的解，往往可以用一个“解空间树”来表示。所以回溯法可以说就是对隐式图的深度优先搜索算法。

### 13.1.3 一般步骤

（

（

（

我们发现，回溯可以用于所有用穷举法可以解决的问题，而动态规划只用于具有最优子结构的问题。动态规划的实质是记忆，需要储存子问题的解，回溯则不需要。所以尽管回溯看起来类似于暴力穷举，但有些问题是无法用动态规划来解决的，就只能采用回溯的方法，比如著名的八皇后问题。

## 13.2 八皇后问题

在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。问有多少种摆法。

![](file:///C:/Users/29315/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

八皇后

### 13.2.1 问题分析

设八个皇后为

l

(1,x1)

表示

(x1,x2,x3,x4,x5,x6,x7,x8)

所以我们可以直接用一个长度为

l

(x1,x2,x3,x4,x5,x6,x7,x8)

共

l

### 13.2.2 方法一：暴力穷举

每一行放一个皇后，可以放在第

毫无疑问，这种方法是非常低效率的，因为它并不是哪里有冲突就调整哪里，而是盲目地按既定顺序枚举所有的可能方案。

代码如下：

**public class **

*// 遍历解空间*

复杂度分析

时间复杂度：

八皇后问题如果用

### 13.2.3 方法二：回溯法

回溯算法

首先，将第一行的皇后放在第一列。之后第二行的皇后，也从放在第一列开始判断，这时已经发生冲突。于是调整第二行的的皇后到第二列，继续冲突就放第三列，直到不冲突为止。

如此可依次放下后续每一行的皇后。当发现某一行的皇后无处放置时，就回溯到上一行，将皇后位置向后继续调整到另一个不冲突的地方。如果上一行也无处放置，继续向上回溯。

直到每一行都无法继续放置，遍历结束。

l

我们发现，一个皇后是否跟其它有冲突，主要取决于当前位置所在的横、纵、斜

![](file:///C:/Users/29315/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

目前我们直接考虑每一行放置一个皇后，那么横向直线就不用考虑了，只需要考虑其它三条线。

纵向比较简单，只要判断同一列是否有皇后就可以了；而对斜向仔细研究规律，可以发现，同一斜线上的格子，横纵坐标是有规律的：

**l**

**l**

![](file:///C:/Users/29315/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

![](file:///C:/Users/29315/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

所以为了在代码中快速判断，当前某个皇后位置是否有效，可以增加三个辅助集合：

l

l

l

每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。

代码如下：

*// 定义辅助集合*

**复杂度分析**

时间复杂度：

空间复杂度：

## 13.3 全排列（#46）

### 13.3.1 题目说明

给定一个

示例

输入

输出

[

 [1,2,3],

 [1,3,2],

 [2,1,3],

 [2,3,1],

 [3,1,2],

 [3,2,1]

]

### 13.3.2 分析

很明显，

这个问题需要暴力穷举。从前到后依次遍历每一个“位置”，每次填入一个数；而之后的一个位置，能够填入的可能性就会少一个。这样，直接用

不过针对本题，数组的长度是不固定的，直接用多重循环的方式显然不妥。我们可以考虑使用递归。每个位置选取某个值，然后递归地对后面位置取值；由于本位置应该还可以取别的多个值，所以应该在一次递归完毕后，还可以“回到”递归调用的地方，继续取下一个值。所以，这就是回溯遍历的方法。

### 13.3.3 回溯实现

我们可以定义一个递归函数

递归函数分为两个情况：

l

l

为了快速判断某个数“尚未使用”，可以用一个

代码如下：

**public class **

**复杂度分析**

时间复杂度：

空间复杂度：

### 13.3.4 代码改进

上面的算法比较容易想到，不过额外使用了一个辅助的

我们发现，

这样，我们得到的，依然是原始

而对于回溯操作，也非常简单：只要把之前交换的两数，再换回来就可以了。

代码如下：

*// 代码改进*

**复杂度分析**

时间复杂度：

空间复杂度：

## 13.4 电话号码的字母组合（#17）

### 13.4.1 题目说明

给定一个仅包含数字 

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](file:///C:/Users/29315/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png)

示例

输入：

输出：

说明

尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

### 13.4.2 分析

给定数字之后，我们需要遍历每个数字对应字母的所有可能，然后进行组合。题目要求我们返回所有可能的字母组合，所以需要穷举所有解。

于是自然想到，我们可以用回溯算法来解决。依次遍历数字，选取可能的字母；递归地进行搜索，直到找到一个可行解，然后进行回溯继续遍历。

### 13.4.3 代码实现

可以用一个哈希表把数字对应的字母存储起来，方便快速查询。

代码如下：

**public class **

**复杂度分析**

时间复杂度：

空间复杂度：