# 第四章 字符串问题讲解

字符串（

字符串与数组有很多相似之处，比如可以使用索引（下标）来得到一个字符。字符串，一般可以认为就是一个字符数组（

在编程语言中，字符串往往由特定字符集内有限的字符组合而成。在

## 4.1 字符串相加（#415）

### 4.1.1 题目说明

给定两个字符串形式的非负整数

提示：

1.

2.

3.

4.

### 4.1.2 分析

这里不允许直接将输入字符串转为整数，那自然想到应该把字符串按每个字符

另外题目要求不能使用

### 4.1.3 代码实现

```
**public class **AddStrings {    
    **public **String addStrings(String num1, Stringnum2) {*        *
        StringBuffer result = **new **StringBuffer();*        *
        **int **i = num1.length() - 1;        
        **int **j = num2.length() - 1;        
        **int **carry = 0;*        *
        **while **( i >= 0 || j >= 0 || carry != 0 ){*            *
            **int **x = i >= 0 ? num1.charAt(i) - **'0' **: 0;*            *
            **int **y = j >= 0 ? num2.charAt(j) - **'0' **: 0;            
            **int **sum = x + y + carry;*             *
            result.append(sum % 10); *            *
            carry = sum / 10;*             *
            i--;            
            j--;        
        }*        *
        **return **result.reverse().toString();    
    }
}
```

### 4.1.4 复杂度分析

时间复杂度：

空间复杂度：

## 4.2 字符串相乘（#43）

### 4.2.1 题目说明

给定两个以字符串形式表示的非负整数

示例

输入

输出

示例

输入

输出

说明：

1.

2.

3.

4.

### 4.2.2 分析

跟“字符串相加”类似，这里我们要处理的，也是大整数的相乘问题。

思路也可以非常类似：我们借鉴数学中“竖式乘法”的规则，用

![](images/WEBRESOURCE1c174611900288143deae38a2bebc146localFile)

### 4.2.3 具体代码实现

```java
**public class **MultiplyStrings {    
    **public **String multiply(String num1, String num2){*        *
        **if **( num1.equals(**"0"**) || num2.equals(**"0"**) ) **return ****"0"**;*        *
        String result = **"0"**;        *// **遍历**num2**的每个数位，逐个与**num1**相乘        *
        **for **( **int **i = num2.length() - 1; i >= 0; i-- ){*            *
            **int **carry = 0;*            *
            StringBuffer curRes = **new **StringBuffer();*            *
            **for **( **int **j = 0; j < num2.length() - 1 - i; j++ ){                
                curRes.append(**"0"**);            
            }            
            **int **y = num2.charAt(i) - **'0'**;*            // **遍历**num1**的每一位数，跟**y**相乘            *
            **for **( **int **j = num1.length() - 1; j >= 0; j-- ){               
            **int **x = num1.charAt(j) - **'0'**;*                *
            **int **product = x * y + carry;*                 *
            curRes.append(product % 10);                
            carry = product / 10;            
        }*            *
        **if **(carry != 0) curRes.append(carry);*           *
            * *AddStrings addStrs = **new **AddStrings();           
              result =addStrs.addStrings(result, curRes.reverse().toString());       
         }        
         **return **result;    
    }
}
```

### 4.2.4 复杂度分析

时间复杂度：

做计算的时候，外层需要从右往左遍历

空间复杂度：

### 4.2.5 算法优化

我们看到计算过程中，用到了太多的字符串相加操作，调用

我们发现，

而且，某两个数位相乘，

![](images/WEBRESOURCE081b671e7ce1b7a7640dce336a12b184localFile)

根据上面的思路，我们可以遍历

代码实现如下：

```java
**public **String multiply(String num1, String num2) {*    *
    **if **( num1.equals(**"0"**) || num2.equals(**"0"**) ) **return ****"0"**;*   *
    **int**[] resultArr = **new int**[num1.length() + num2.length()];    *// 遍历num1和num2，逐位计算乘积，填入结果数组中    *
    **for **( **int **i = num1.length() - 1; i >= 0; i-- ){        
         **int **x = num1.charAt(i) - **'0'**;        
         **for **( **int **j = num2.length() - 1; j >= 0; j-- ){            
             **int **y = num2.charAt(j) - **'0'**;            
             **int **product = x * y;*            *
             **int **temp = resultArr[i+j+1] + product;            
             resultArr[i+j+1] = temp % 10;            
             resultArr[i+j] += temp / 10;        
         }    
       }*    *
       StringBuffer result = **new **StringBuffer();    
       **int **start = resultArr[0] == 0 ? 1 : 0;*     *
       **for **( **int **i = start; i < resultArr.**length**; i++ ){        
           result.append(resultArr[i]);    
       }    
       **return **result.toString();}
```

**复杂度分析**

时间复杂度：

空间复杂度：

## 4.3 去除重复字母（#316）

### 4.3.1 题目说明

给你一个字符串

示例

输入：

输出：

示例

输入：

输出：

提示：

l

l

### 4.3.2 分析

首先要知道什么叫“字典序”。

字符串之间比较跟数字之间比较是不太一样的：字符串比较，是从头往后一个字符一个字符比较的，哪个字符串大取决于两个字符串中

所以，任意一个以

为了得到最小字典序的结果，解题过程中，我们可以将最小的字符尽可能的放在前面，把前面出现的重复字母全部删除。这其实就是一个

### 4.3.3 方法一：贪心策略（逐个字符处理）

这种想法就是典型的贪心策略了：我们每次都找到当前能够移到最左边的、最小的字母。这就是我们得到结果的第一个字母，它之前的所有重复字母会被删掉；然后我们从它以后的字符串中，使用相同的逻辑，继续寻找第二个最小的字母。

所以，我们在代码实现上，可以使用递归。

代码如下：

**public class **

+ removeDuplicateLetters0(

s.substring(position+

.replaceAll(

复杂度分析

l

l

### 4.4.4 方法二：贪心策略改进

我们发现，对于“是否重复出现”的判断，每次都要偏离当前字母之后的所有字符，这显然做了很多重复工作。

优化的方法，我们可以用一个

代码实现：

**public **

removeDuplicateLetters(s.substring(position+

.replaceAll(

**复杂度分析**

l

l

### 4.4.5 方法三：贪心策略（用栈实现）

上面的方法由于递归的时候，用到了字符串切片的方法，导致必须要有线性的空间复杂度，而且运行时间也并不短。那还没有别的优化方法呢？

这就需要结合其它的数据结构了。我们可以用栈来存储最终返回的字符串。

代码实现如下：

```
**public **String removeDuplicateLetters(String s) {*    *
    Stack<Character> stack = **new **Stack<>();*    *
    HashSet<Character> seen = **new **HashSet<>();*    *
    HashMap<Character, Integer> last_occur = **new **HashMap<>();    
    **for **(**int **i = 0; i < s.length(); i++){        
        last_occur.put(s.charAt(i), i);*     *
    }    *// **遍历字符串，判断是否入栈   *
* *   **for **(**int **i = 0; i < s.length(); i++){       
        **char **c = s.charAt(i);*        *
        **if **(!seen.contains(c)){*            *
            **while **(!stack.isEmpty() &&   c < stack.peek()&&   last_occur.get(stack.peek()) >i){                
                seen.remove(stack.pop());*            *
            }*           *
            seen.add(c);            
            stack.push(c);        
        }    
   }    *// **将栈中元素保存成字符串输出    *
    StringBuilder sb = **new **StringBuilder(stack.size());    
    **for **(Character c: stack){        
        sb.append(c.charValue());*    *
    }    
    **return **sb.toString();
}
```

**复杂度分析**

时间复杂度：

空间复杂度：