# 第六章 链表问题讲解

链表（

![](images/WEBRESOURCE8721c4d351ce704aab201613cc624734localFile)

由于不必须按顺序存储，链表在插入的时候可以达到

链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。

## 6.1 反转链表（#206）

### 6.1.1 题目说明

反转一个单链表。

示例

输入

输出

进阶

你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

### 6.1.2 分析

链表的节点结构

从代码实现上看，可以有迭代和递归两种形式。

### 6.1.3 方法一：迭代

假设存在链表

我们只需要依次迭代节点遍历链表，在迭代过程中，将当前节点的

代码如下：

**public class **

**复杂度分析**

时间复杂度：

空间复杂度：

### 6.1.4 方法二：递归

递归的核心，在于当前只考虑一个节点。剩下部分可以递归调用，直接返回一个反转好的链表，然后只要把当前节点再接上去就可以了。

假设链表为（长度为

n1 

若我们遍历到了

n1 

我们现在希望

n

代码如下：

**public **

**复杂度分析**

时间复杂度：时间复杂度：

空间复杂度：

## 6.2 合并两个有序链表（#21）

### 6.2.1 题目说明

将两个升序链表合并为一个新的

示例：

输入：

输出：

### 6.2.2 分析

链表节点结构已经定义好，而且已经做了升序排列。现在我们需要分别遍历两个链表，然后依次比较，按从小到大的顺序生成新的链表就可以了。这其实就是“归并排序”的思路。

### 6.2.3 方法一：迭代

最简单的想法，就是逐个遍历两个链表中的节点，依次比对。

我们假设原链表为

另外，为了让代码更加简洁，我们可以引入一个哨兵节点（

代码如下：

**public class **

**复杂度分析**

时间复杂度：

空间复杂度：

### 6.2.4 方法二：递归

用递归的方式同样可以实现上面的过程。

当两个链表都不为空时，我们需要比对当前两条链的头节点。取出较小的那个节点；而两条链其余的部分，可以递归调用，认为它们已经排好序。所以我们需要做的，就是把前面取出的那个节点，接到剩余排好序的链表头节点前。

代码如下：

**public **

**复杂度分析**

时间复杂度：

空间复杂度：

## 6.3 删除链表的倒数第N个节点（#19）

### 6.3.1 题目说明

给定一个链表，删除链表的倒数第

示例：

给定一个链表

当删除了倒数第二个节点后，链表变为

说明：

给定的

进阶：

你能尝试使用一趟扫描实现吗？

### 6.3.2 分析

在链表中删除某个节点，其实就是将之前一个节点

当然，真正意义上的删除，还应该回收节点本身占用的空间，进行内存管理。这一点在

### 6.3.3 方法一：计算链表长度（二次遍历）

最简单的想法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度

然后，我们再从头节点开始对链表进行一次遍历，当遍历到第

这样，总共做两次遍历，我们就可以得到结果。

代码如下：

**public class **

**int **

}

**复杂度分析**

时间复杂度：

空间复杂度：

### 6.3.4 方法二：利用栈

另一个思路是利用栈数据结构。因为栈是“先进后出”的，所以我们可以在遍历链表的同时将所有节点依次入栈，然后再依次弹出。

这样，弹出栈的第

代码如下：

**public **

**复杂度分析**

时间复杂度：

空间复杂度：

### 6.3.5 方法三：双指针（一次遍历）

我们可以使用两个指针

这样，它们总是保持着

代码如下：

**public **

**复杂度分析**

时间复杂度：

空间复杂度：